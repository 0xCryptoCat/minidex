{
    "sourceFile": "netlify/functions/lists.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755456083081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755456083081,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type {\n  ListsResponse,\n  ApiError,\n  ListType,\n  Window,\n  ListItem,\n} from '../../src/lib/types';\nimport fs from 'fs/promises';\nimport { CHAIN_TO_GT_NETWORK } from '../shared/chains';\n\nconst FIXTURES: Record<string, string> = {\n  'trending:ethereum:1h': '../../fixtures/lists-trending-eth-1h.json',\n  'discovery:ethereum:1d': '../../fixtures/lists-discovery-eth-1d.json',\n  'leaderboard:ethereum:1d': '../../fixtures/lists-leaderboard-eth-1d.json',\n};\n\nconst USE_FIXTURES = process.env.USE_FIXTURES === 'true';\nconst GT_API_BASE = process.env.GT_API_BASE || '';\nconst GT_API_KEY = process.env.GT_API_KEY || '';\nconst DS_API_BASE = process.env.DS_API_BASE || '';\nconst CG_API_BASE = process.env.COINGECKO_API_BASE || '';\nconst CG_API_KEY = process.env.COINGECKO_API_KEY || '';\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[lists]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[lists]', ...args);\n}\n\nfunction isValidType(t?: string): t is ListType {\n  return t === 'trending' || t === 'discovery' || t === 'leaderboard';\n}\nfunction isValidWindow(w?: string): w is Window {\n  return w === '1h' || w === '1d' || w === '1w';\n}\n\nasync function readFixture(path: string): Promise<ListsResponse> {\n  const url = new URL(path, import.meta.url);\n  const data = await fs.readFile(url, 'utf8');\n  return JSON.parse(data) as ListsResponse;\n}\n\nasync function fetchJson(url: string, init?: RequestInit): Promise<any> {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), 3000);\n  try {\n    const res = await fetch(url, { signal: controller.signal, ...(init || {}) });\n    if (!res.ok) throw new Error('status');\n    return await res.json();\n  } catch (err) {\n    logError('fetch error', url, err);\n    throw err;\n  } finally {\n    clearTimeout(id);\n  }\n}\n\n// Static popular tokens per chain used to approximate trending when GT is\n// unavailable. Addresses are checksummed.\nconst DS_POPULAR: Record<string, string[]> = {\n  ethereum: [\n    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH\n    '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n    '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT\n    '0x6B175474E89094C44Da98b954EedeAC495271d0F', // DAI\n    '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', // WBTC\n  ],\n};\n\nfunction rank(items: ListItem[]): void {\n  let maxVol = 0;\n  let maxPrice = 0;\n  let maxTrades = 0;\n  for (const it of items) {\n    if (it.volWindowUsd && it.volWindowUsd > maxVol) maxVol = it.volWindowUsd;\n    if (it.priceChangePct !== undefined) {\n      const p = Math.abs(it.priceChangePct);\n      if (p > maxPrice) maxPrice = p;\n    }\n    if (it.tradesWindow && it.tradesWindow > maxTrades) maxTrades = it.tradesWindow;\n  }\n  for (const it of items) {\n    const volScore = maxVol ? (it.volWindowUsd || 0) / maxVol : 0;\n    const priceScore = maxPrice ? Math.abs(it.priceChangePct || 0) / maxPrice : 0;\n    const tradeScore = maxTrades ? (it.tradesWindow || 0) / maxTrades : 0;\n    it.score = 0.5 * volScore + 0.3 * priceScore + 0.2 * tradeScore;\n  }\n  items.sort((a, b) => {\n    const diff = (b.score || 0) - (a.score || 0);\n    if (diff !== 0) return diff;\n    return a.pairId.localeCompare(b.pairId);\n  });\n}\n\nexport const handler: Handler = async (event) => {\n  const chain = event.queryStringParameters?.chain;\n  const type = event.queryStringParameters?.type as ListType | undefined;\n  const window = event.queryStringParameters?.window as Window | undefined;\n  const limitParam = event.queryStringParameters?.limit;\n  const limit = limitParam ? parseInt(limitParam, 10) : undefined;\n\n  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n\n  log('params', { chain, type, window, limit });\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=60, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n  };\n  if (!isValidType(type) || !isValidWindow(window)) {\n    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n    return { statusCode: 400, headers, body: JSON.stringify(body) };\n  }\n  const attempted: string[] = [];\n  try {\n\n  if (!chain) {\n    const bodyRes: ListsResponse = { chain: '', type: type!, window: window!, items: [], provider: 'none' };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n  }\n  if (!SUPPORTED_CHAINS.includes(chain)) {\n    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(body) };\n  }\n\n  const key = `${type}:${chain}:${window}`;\n  if (USE_FIXTURES) {\n    const path = FIXTURES[key];\n    if (!path) {\n      const body: ApiError = { error: 'not_found', provider: 'none' };\n      return { statusCode: 404, headers, body: JSON.stringify(body) };\n    }\n    try {\n      const data = await readFixture(path);\n      rank(data.items);\n      if (limit !== undefined) data.items = data.items.slice(0, limit);\n      return { statusCode: 200, headers, body: JSON.stringify(data) };\n    } catch (err) {\n      logError('fixture read failed', err);\n      const body: ApiError = { error: 'upstream_error', provider: 'none' };\n      return { statusCode: 500, headers, body: JSON.stringify(body) };\n    }\n  }\n\n  const items: ListItem[] = [];\n  let provider: 'gt' | 'ds' | 'cg' | 'none' = 'none';\n\n  if (GT_API_BASE) {\n    attempted.push('gt');\n    try {\n      const gtUrl = `${GT_API_BASE}/networks/${chain}/${type}?window=${window}${\n        limit ? `&limit=${limit}` : ''\n      }`;\n      const init = GT_API_KEY ? { headers: { 'X-API-KEY': GT_API_KEY } } : undefined;\n      const gt = await fetchJson(gtUrl, init);\n      const dataArray = Array.isArray(gt?.data)\n        ? gt.data\n        : Array.isArray(gt?.items)\n        ? gt.items\n        : [];\n\n      dataArray.forEach((d: any) => {\n        const attr = d.attributes || {};\n        const token = attr.base_token || attr.token || {};\n        const volMap = attr.volume_usd || attr.volume || {};\n        const priceChangeMap = attr.price_change_percentage || attr.priceChangePct || {};\n        const txMap = attr.transaction_count || attr.txns || {};\n        const windowKey = window === '1h' ? 'h1' : window === '1d' ? 'h24' : 'h7';\n        const volWindow = volMap[windowKey];\n        const priceChange = priceChangeMap[windowKey];\n        const tradesWindow = txMap[windowKey];\n        const createdAt = attr.pool_created_at\n          ? Math.floor(new Date(attr.pool_created_at).getTime() / 1000)\n          : attr.created_at\n          ? Math.floor(new Date(attr.created_at).getTime() / 1000)\n          : undefined;\n        items.push({\n          pairId: d.id || attr.pool_id || attr.address,\n          chain: chain as string,\n          token: {\n            address: token.address,\n            symbol: token.symbol,\n            name: token.name,\n          },\n          priceUsd:\n            attr.base_token_price_usd !== undefined\n              ? Number(attr.base_token_price_usd)\n              : attr.price_usd !== undefined\n              ? Number(attr.price_usd)\n              : undefined,\n          liqUsd: attr.liquidity_usd !== undefined ? Number(attr.liquidity_usd) : undefined,\n          volWindowUsd: volWindow !== undefined ? Number(volWindow) : undefined,\n          priceChangePct: priceChange !== undefined ? Number(priceChange) : undefined,\n          tradesWindow: tradesWindow !== undefined ? Number(tradesWindow) : undefined,\n          createdAt,\n        });\n      });\n      if (items.length > 0) {\n        rank(items);\n        provider = 'gt';\n        log('gt items', items.length);\n      }\n    } catch (err) {\n      logError('gt fetch failed', err);\n      // noop, will fall back to DS\n    }\n  }\n\n  if (items.length === 0 && CG_API_BASE && CG_API_KEY) {\n    attempted.push('cg');\n    try {\n      const cgUrl = `${CG_API_BASE}/trending/${chain}?window=${window}`;\n      const cg = await fetchJson(cgUrl, {\n        headers: { 'x-cg-pro-api-key': CG_API_KEY },\n      });\n      const dataArray = Array.isArray(cg?.data) ? cg.data : [];\n      dataArray.forEach((d: any) => {\n        const attr = d.attributes || d;\n        const token = attr.base_token || attr.token || {};\n        const volMap = attr.volume_usd || attr.volume || {};\n        const priceChangeMap = attr.price_change_percentage || attr.priceChangePct || {};\n        const txMap = attr.transaction_count || attr.txns || {};\n        const windowKey = window === '1h' ? 'h1' : window === '1d' ? 'h24' : 'h7';\n        const volWindow = volMap[windowKey];\n        const priceChange = priceChangeMap[windowKey];\n        const tradesWindow = txMap[windowKey];\n        items.push({\n          pairId: d.id || attr.pool_id || attr.address || token.address,\n          chain: chain!,\n          token: {\n            address: token.address,\n            symbol: token.symbol,\n            name: token.name,\n          },\n          priceUsd:\n            attr.base_token_price_usd !== undefined\n              ? Number(attr.base_token_price_usd)\n              : attr.price_usd !== undefined\n              ? Number(attr.price_usd)\n              : undefined,\n          liqUsd:\n            attr.liquidity_usd !== undefined ? Number(attr.liquidity_usd) : undefined,\n          volWindowUsd: volWindow !== undefined ? Number(volWindow) : undefined,\n          priceChangePct: priceChange !== undefined ? Number(priceChange) : undefined,\n          tradesWindow: tradesWindow !== undefined ? Number(tradesWindow) : undefined,\n          createdAt:\n            attr.pool_created_at\n              ? Math.floor(new Date(attr.pool_created_at).getTime() / 1000)\n              : attr.created_at\n              ? Math.floor(new Date(attr.created_at).getTime() / 1000)\n              : undefined,\n        });\n      });\n      if (items.length > 0) {\n        rank(items);\n        provider = 'cg';\n        log('cg items', items.length);\n      }\n    } catch (err) {\n      logError('cg fetch failed', err);\n      // ignore, fall through\n    }\n  }\n\n  if (items.length === 0 && DS_API_BASE) {\n    attempted.push('ds');\n    const addresses = DS_POPULAR[chain] || [];\n    for (const addr of addresses.slice(0, limit ?? addresses.length)) {\n      try {\n        const ds = await fetchJson(`${DS_API_BASE}/dex/tokens/${addr}`);\n        const first = Array.isArray(ds.pairs) ? ds.pairs[0] : undefined;\n        if (!first) continue;\n        items.push({\n          pairId: first.pairAddress || first.id || addr,\n          chain: chain!,\n          token: {\n            address: addr as `0x${string}`,\n            symbol: (ds.token && ds.token.symbol) || first.baseToken?.symbol,\n            name: (ds.token && ds.token.name) || first.baseToken?.name,\n          },\n          priceUsd:\n            first.priceUsd !== undefined\n              ? Number(first.priceUsd)\n              : first.price_usd !== undefined\n              ? Number(first.price_usd)\n              : undefined,\n          liqUsd:\n            first.liquidity?.usd !== undefined\n              ? Number(first.liquidity.usd)\n              : first.liquidityUsd !== undefined\n              ? Number(first.liquidityUsd)\n              : undefined,\n          volWindowUsd:\n            first.volume?.h24 !== undefined\n              ? Number(first.volume.h24)\n              : first.vol24hUsd !== undefined\n              ? Number(first.vol24hUsd)\n              : undefined,\n          priceChangePct:\n            first.priceChange?.h24 !== undefined\n              ? Number(first.priceChange.h24)\n              : first.priceChange24hPct !== undefined\n              ? Number(first.priceChange24hPct)\n              : undefined,\n          createdAt:\n            first.pairCreatedAt !== undefined\n              ? Math.floor(new Date(first.pairCreatedAt).getTime() / 1000)\n              : undefined,\n        });\n      } catch (err) {\n        logError('ds fetch failed', addr, err);\n        // ignore individual failures\n      }\n    }\n    if (items.length > 0) {\n      rank(items);\n      provider = 'ds';\n      log('ds items', items.length);\n    }\n  }\n\n    const limited = limit !== undefined ? items.slice(0, limit) : items;\n    const bodyRes: ListsResponse = { chain, type, window, items: limited, provider };\n    headers['x-provider'] = provider;\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    headers['x-items'] = String(limited.length);\n    log('response', event.rawUrl, 200, limited.length, provider);\n    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n  } catch (err) {\n    logError('handler error', err);\n    const body: ApiError = { error: 'internal_error', provider: 'none' };\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n};\n"
        }
    ]
}