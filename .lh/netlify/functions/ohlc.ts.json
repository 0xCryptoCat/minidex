{
    "sourceFile": "netlify/functions/ohlc.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1755456083080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755518756787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,17 +83,44 @@\n   }\n   return deduped;\n }\n \n+function isValidPoolAddress(addr?: string, chain?: string): boolean {\n+  if (!addr) return false;\n+\n+  // EVM chains: 0x followed by 40 hex characters\n+  if (chain && ['ethereum', 'bsc', 'polygon', 'arbitrum', 'optimism', 'avalanche', 'base', 'fantom', 'linea', 'scroll', 'zksync', 'mantle', 'moonbeam', 'moonriver', 'cronos', 'harmony', 'celo', 'aurora', 'metis', 'boba', 'kava', 'gnosis'].includes(chain)) {\n+    return /^0x[a-fA-F0-9]{40}$/.test(addr);\n+  }\n+\n+  // Solana: base58 encoded, typically 32-44 chars\n+  if (chain === 'solana') {\n+    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);\n+  }\n+\n+  // TON: EQxxxx or UQxxxx format\n+  if (chain === 'ton') {\n+    return /^(EQ|UQ)[A-Za-z0-9_-]{46}$/.test(addr);\n+  }\n+\n+  // SUI: 0x followed by 64 hex characters\n+  if (chain === 'sui') {\n+    return /^0x[a-fA-F0-9]{64}$/.test(addr);\n+  }\n+\n+  // For other chains, be more permissive\n+  return addr.length >= 10 && addr.length <= 100;\n+}\n+\n export const handler: Handler = async (event) => {\n   const pairId = event.queryStringParameters?.pairId;\n   const tf = event.queryStringParameters?.tf as Timeframe | undefined;\n   const chain = event.queryStringParameters?.chain;\n   const poolAddress = event.queryStringParameters?.poolAddress;\n   const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n   const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n   const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n-  const validPool = /^0x[0-9a-fA-F]{40}$/.test(poolAddress || '');\n+  const validPool = isValidPoolAddress(poolAddress, chain);\n   const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n \n   const headers: Record<string, string> = {\n     'Content-Type': 'application/json',\n"
                },
                {
                    "date": 1756118507451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -323,8 +323,9 @@\n                   attrs.amount_base ??\n                   attrs.amount_base_token ??\n                   '0'\n               ),\n+              volumeUSD: parseFloat(attrs.volume_in_usd ?? '0'), // Map volume_in_usd from API\n             } as Trade;\n           });\n         }\n       } catch (err) {\n"
                },
                {
                    "date": 1756118813074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -349,8 +349,9 @@\n               price: parseFloat(attrs.price_to_in_usd ?? attrs.price_from_in_usd ?? '0'),\n               amountBase: parseFloat(\n                 attrs.to_token_amount ?? attrs.from_token_amount ?? '0'\n               ),\n+              volumeUSD: parseFloat(attrs.volume_in_usd ?? '0'), // Map volume_in_usd from GT API\n             } as Trade;\n           });\n         }\n       } catch (err) {\n"
                },
                {
                    "date": 1756119230412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -323,9 +323,9 @@\n                   attrs.amount_base ??\n                   attrs.amount_base_token ??\n                   '0'\n               ),\n-              volumeUSD: parseFloat(attrs.volume_in_usd ?? '0'), // Map volume_in_usd from API\n+              volumeUSD: parseFloat(attrs.volume_in_usd || '0'), // Parse volume_in_usd string from API\n             } as Trade;\n           });\n         }\n       } catch (err) {\n@@ -349,9 +349,9 @@\n               price: parseFloat(attrs.price_to_in_usd ?? attrs.price_from_in_usd ?? '0'),\n               amountBase: parseFloat(\n                 attrs.to_token_amount ?? attrs.from_token_amount ?? '0'\n               ),\n-              volumeUSD: parseFloat(attrs.volume_in_usd ?? '0'), // Map volume_in_usd from GT API\n+              volumeUSD: parseFloat(attrs.volume_in_usd || '0'), // Parse volume_in_usd string from GT API\n             } as Trade;\n           });\n         }\n       } catch (err) {\n"
                },
                {
                    "date": 1756119729753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -308,21 +308,21 @@\n                 : Number(tsRaw);\n             return {\n               ts,\n               price: parseFloat(\n-                attrs.price_to_in_usd ??\n-                  attrs.price_from_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n+                attrs.price_to_in_usd ||\n+                  attrs.price_from_in_usd ||\n+                  attrs.price_usd ||\n+                  attrs.priceUsd ||\n+                  attrs.price ||\n+                  attrs[1] ||\n                   '0'\n               ),\n               amountBase: parseFloat(\n-                attrs.to_token_amount ??\n-                  attrs.from_token_amount ??\n-                  attrs.amount_base ??\n-                  attrs.amount_base_token ??\n+                attrs.to_token_amount ||\n+                  attrs.from_token_amount ||\n+                  attrs.amount_base ||\n+                  attrs.amount_base_token ||\n                   '0'\n               ),\n               volumeUSD: parseFloat(attrs.volume_in_usd || '0'), // Parse volume_in_usd string from API\n             } as Trade;\n@@ -345,11 +345,11 @@\n           trades = list.map((t: any) => {\n             const attrs = t.attributes || {};\n             return {\n               ts: Math.floor(new Date(attrs.block_timestamp).getTime() / 1000),\n-              price: parseFloat(attrs.price_to_in_usd ?? attrs.price_from_in_usd ?? '0'),\n+              price: parseFloat(attrs.price_to_in_usd || attrs.price_from_in_usd || '0'),\n               amountBase: parseFloat(\n-                attrs.to_token_amount ?? attrs.from_token_amount ?? '0'\n+                attrs.to_token_amount || attrs.from_token_amount || '0'\n               ),\n               volumeUSD: parseFloat(attrs.volume_in_usd || '0'), // Parse volume_in_usd string from GT API\n             } as Trade;\n           });\n"
                }
            ],
            "date": 1755456083080,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type {\n  OHLCResponse,\n  ApiError,\n  Provider,\n  Timeframe,\n  Trade,\n  Candle,\n} from '../../src/lib/types';\nimport fs from 'fs/promises';\nimport { CHAIN_TO_GT_NETWORK } from '../shared/chains';\nimport { buildCandlesFromTrades } from '../shared/agg';\nimport { MAP_TF_GT, MAP_TF_CG, TF_SECONDS } from '../../src/lib/timeframes';\n\nconst GT_FIXTURE = '../../fixtures/ohlc-gt-1m.json';\nconst DS_FIXTURE = '../../fixtures/ohlc-ds-1m.json';\n\nconst USE_FIXTURES = process.env.USE_FIXTURES === 'true';\nconst GT_API_BASE = process.env.GT_API_BASE || 'https://api.geckoterminal.com/api/v2';\nconst CG_API_BASE = process.env.COINGECKO_API_BASE || '';\nconst CG_API_KEY = process.env.COINGECKO_API_KEY || '';\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[ohlc]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[ohlc]', ...args);\n}\n\nfunction isValidPair(id?: string): id is string {\n  return !!id;\n}\n\nfunction isValidTf(tf?: string): tf is Timeframe {\n  return !!tf;\n}\n\nasync function readFixture(path: string): Promise<OHLCResponse> {\n  const url = new URL(path, import.meta.url);\n  const data = await fs.readFile(url, 'utf8');\n  return JSON.parse(data) as OHLCResponse;\n}\n\nfunction sanitizeCandles(candles: Candle[]): Candle[] {\n  const now = Math.floor(Date.now() / 1000) + 60;\n  const out: Candle[] = [];\n  for (const c of candles) {\n    let t = Number(c.t);\n    let o = Number(c.o);\n    let h = Number(c.h);\n    let l = Number(c.l);\n    let close = Number(c.c);\n    let v = c.v !== undefined ? Number(c.v) : undefined;\n    if (![t, o, h, l, close].every(Number.isFinite)) continue;\n    if (t > now) continue;\n    if (h < l) {\n      const tmp = h;\n      h = l;\n      l = tmp;\n    }\n    if (o > h) o = h;\n    if (o < l) o = l;\n    if (close > h) close = h;\n    if (close < l) close = l;\n    o = parseFloat(o.toFixed(12));\n    h = parseFloat(h.toFixed(12));\n    l = parseFloat(l.toFixed(12));\n    close = parseFloat(close.toFixed(12));\n    if (v !== undefined) v = parseFloat(v.toFixed(12));\n    out.push({ t: Math.floor(t), o, h, l, c: close, v });\n  }\n  out.sort((a, b) => a.t - b.t);\n  const deduped: Candle[] = [];\n  for (const c of out) {\n    const prev = deduped[deduped.length - 1];\n    if (prev && prev.t === c.t) {\n      deduped[deduped.length - 1] = c;\n    } else {\n      deduped.push(c);\n    }\n  }\n  return deduped;\n}\n\nexport const handler: Handler = async (event) => {\n  const pairId = event.queryStringParameters?.pairId;\n  const tf = event.queryStringParameters?.tf as Timeframe | undefined;\n  const chain = event.queryStringParameters?.chain;\n  const poolAddress = event.queryStringParameters?.poolAddress;\n  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n  const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n  const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n  const validPool = /^0x[0-9a-fA-F]{40}$/.test(poolAddress || '');\n  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n  };\n  const attempted: string[] = [];\n  if (!CG_API_KEY) attempted.push('cg:disabled');\n  if (!isValidPair(pairId) || !isValidTf(tf) || !chain) {\n    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n    log('response', event.rawUrl, 400, 0, 'none');\n    return { statusCode: 400, headers, body: JSON.stringify(body) };\n  }\n  if (!SUPPORTED_CHAINS.includes(chain)) {\n    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(body) };\n  }\n  try {\n    if (USE_FIXTURES) {\n    try {\n      if (forceProvider !== 'gt') {\n        const ds = await readFixture(DS_FIXTURE);\n        ds.pairId = pairId;\n        if (tf !== '1m') {\n          ds.rollupHint = 'client';\n        }\n        return { statusCode: 200, headers, body: JSON.stringify(ds) };\n      }\n      throw new Error('force gt');\n    } catch (err) {\n      logError('ds fixture failed', err);\n      try {\n        const gt = await readFixture(GT_FIXTURE);\n        gt.pairId = pairId;\n        if (tf !== '1m') {\n          gt.rollupHint = 'client';\n        }\n        return { statusCode: 200, headers, body: JSON.stringify(gt) };\n      } catch (err2) {\n        logError('gt fixture failed', err2);\n        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n        return { statusCode: 500, headers, body: JSON.stringify(body) };\n      }\n    }\n  }\n\n  let candles: Candle[] = [];\n  let provider: Provider | 'none' = 'none';\n  let effectiveTf: Timeframe | undefined;\n\n  log('params', { pairId, tf, chain, poolAddress, forceProvider, gtSupported, gtNetwork });\n\n  if (!gtNetwork) {\n    log('skip gt: invalid network', chain);\n  }\n  if (!validPool) {\n    headers['x-invalid-pool'] = '1';\n    log('skip gt: invalid pool', poolAddress);\n  }\n\n  if (\n    (forceProvider === 'gt' || (!forceProvider && gtSupported)) &&\n    gtNetwork &&\n    validPool\n  ) {\n    attempted.push('gt');\n    const ladder = ['5m', '15m', '1h'];\n    const tfs = [tf, ...ladder.filter((t) => t !== tf)];\n    for (const t of tfs) {\n      try {\n        const gtTf = MAP_TF_GT[t] || 'minute';\n        const gtUrl = `${GT_API_BASE}/networks/${gtNetwork}/pools/${poolAddress}/ohlcv/${gtTf}`;\n        const gtResp = await fetch(gtUrl);\n        if (!gtResp.ok) continue;\n        const gtData = await gtResp.json();\n        const list = gtData?.data?.attributes?.ohlcv_list || [];\n        const raw = Array.isArray(list)\n          ? list.map((c: any) => ({\n              t: Number(c[0]),\n              o: Number(c[1]),\n              h: Number(c[2]),\n              l: Number(c[3]),\n              c: Number(c[4]),\n              v: c[5] !== undefined ? Number(c[5]) : undefined,\n            }))\n          : [];\n        const candlesGt = sanitizeCandles(raw);\n        if (candlesGt.length > 0) {\n          log('gt candles', candlesGt.length);\n          candles = candlesGt;\n          provider = 'gt';\n          effectiveTf = t as Timeframe;\n          break;\n        }\n      } catch (err) {\n        logError('gt ohlc fetch failed', err);\n        // ignore\n      }\n    }\n  }\n\n  if (\n    candles.length === 0 &&\n    forceProvider !== 'gt' &&\n    CG_API_BASE &&\n    CG_API_KEY &&\n    chain &&\n    poolAddress\n  ) {\n    attempted.push('cg');\n    try {\n      const interval = MAP_TF_CG[tf] || '1m';\n      const cgUrl = `${CG_API_BASE}/pool-ohlcv-contract-address?chain=${chain}&address=${poolAddress}&interval=${interval}`;\n      const res = await fetch(cgUrl, { headers: { 'x-cg-pro-api-key': CG_API_KEY } });\n      if (res.status === 401 || res.status === 403) {\n        headers['x-cg-auth'] = 'fail';\n        log('cg auth fail', res.status);\n      }\n      if (res.ok) {\n        const cg = await res.json();\n        const list = Array.isArray(cg?.data)\n          ? cg.data\n          : Array.isArray(cg?.candles)\n          ? cg.candles\n          : Array.isArray(cg)\n          ? cg\n          : [];\n        const raw = list.map((c: any) => ({\n          t: Number(c[0] ?? c.timestamp),\n          o: Number(c[1] ?? c.open),\n          h: Number(c[2] ?? c.high),\n          l: Number(c[3] ?? c.low),\n          c: Number(c[4] ?? c.close),\n          v:\n            c[5] !== undefined\n              ? Number(c[5])\n              : c.volume !== undefined\n              ? Number(c.volume)\n              : undefined,\n        }));\n        const candlesCg = sanitizeCandles(raw);\n        if (candlesCg.length > 0) {\n          candles = candlesCg;\n          provider = 'cg';\n          effectiveTf = tf;\n          log('cg candles', candles.length);\n        }\n      }\n    } catch (err) {\n      logError('cg ohlc fetch failed', err);\n      // ignore\n    }\n  }\n\n  if (candles.length === 0) {\n    let trades: Trade[] = [];\n    if (CG_API_BASE && CG_API_KEY && chain && poolAddress) {\n      attempted.push('cg-trades');\n      try {\n        const cgUrl = `${CG_API_BASE}/pool-trades-contract-address?chain=${chain}&address=${poolAddress}&limit=300`;\n        const res = await fetch(cgUrl, { headers: { 'x-cg-pro-api-key': CG_API_KEY } });\n        if (res.status === 401 || res.status === 403) {\n          headers['x-cg-auth'] = 'fail';\n          log('cg auth fail', res.status);\n        }\n        if (res.ok) {\n          const cg = await res.json();\n          const list = Array.isArray(cg?.data)\n            ? cg.data\n            : Array.isArray(cg?.trades)\n            ? cg.trades\n            : Array.isArray(cg)\n            ? cg\n            : [];\n          trades = list.map((t: any) => {\n            const attrs = t.attributes || t;\n            const tsRaw =\n              attrs.block_timestamp ?? attrs.timestamp ?? attrs.ts ?? attrs.time ?? attrs[0];\n            const ts =\n              typeof tsRaw === 'string' && !/^[0-9]+$/.test(tsRaw)\n                ? Math.floor(new Date(tsRaw).getTime() / 1000)\n                : Number(tsRaw);\n            return {\n              ts,\n              price: parseFloat(\n                attrs.price_to_in_usd ??\n                  attrs.price_from_in_usd ??\n                  attrs.price_usd ??\n                  attrs.priceUsd ??\n                  attrs.price ??\n                  attrs[1] ??\n                  '0'\n              ),\n              amountBase: parseFloat(\n                attrs.to_token_amount ??\n                  attrs.from_token_amount ??\n                  attrs.amount_base ??\n                  attrs.amount_base_token ??\n                  '0'\n              ),\n            } as Trade;\n          });\n        }\n      } catch (err) {\n        logError('cg trades fetch failed', err);\n        // ignore\n      }\n    }\n\n    if (trades.length === 0 && gtSupported && gtNetwork && validPool) {\n      attempted.push('gt-trades');\n      try {\n        const gtUrl = `${GT_API_BASE}/networks/${gtNetwork}/pools/${poolAddress}/trades?limit=300`;\n        const resp = await fetch(gtUrl);\n        if (resp.ok) {\n          const gtData = await resp.json();\n          const list = Array.isArray(gtData.data) ? gtData.data : [];\n          trades = list.map((t: any) => {\n            const attrs = t.attributes || {};\n            return {\n              ts: Math.floor(new Date(attrs.block_timestamp).getTime() / 1000),\n              price: parseFloat(attrs.price_to_in_usd ?? attrs.price_from_in_usd ?? '0'),\n              amountBase: parseFloat(\n                attrs.to_token_amount ?? attrs.from_token_amount ?? '0'\n              ),\n            } as Trade;\n          });\n        }\n      } catch (err) {\n        logError('gt trades fetch failed', err);\n        // ignore\n      }\n    }\n\n    if (trades.length > 0) {\n      effectiveTf = effectiveTf || tf;\n      const tfSec = TF_SECONDS[effectiveTf] || 60;\n      candles = sanitizeCandles(buildCandlesFromTrades(trades, tfSec));\n      provider = 'synthetic';\n      headers['x-provider'] = 'synthetic';\n      headers['x-synthesized-from'] = 'trades';\n    }\n  }\n\n  candles = sanitizeCandles(candles);\n\n  const bodyRes: OHLCResponse = { pairId, tf, candles, provider: provider as Provider, effectiveTf };\n  headers['x-provider'] = provider;\n  headers['x-fallbacks-tried'] = attempted.join(',');\n  headers['x-items'] = String(candles.length);\n  headers['x-effective-tf'] = effectiveTf || tf;\n  log('response', event.rawUrl, 200, candles.length, provider);\n  return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n  } catch (err) {\n    logError('handler error', err);\n    const body: ApiError = { error: 'internal_error', provider: 'none' };\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n};\n\n"
        }
    ]
}