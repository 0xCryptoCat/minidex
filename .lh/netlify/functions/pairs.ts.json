{
    "sourceFile": "netlify/functions/pairs.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1755434210881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755434241880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import type { Handler } from '@netlify/functions';\n+import type { Handler } from '.netlify/functions';\n import type {\n   PairsResponse,\n   ApiError,\n   Provider,\n"
                },
                {
                    "date": 1755434253040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import type { Handler } from '.netlify/functions';\n+import type { Handler } from '@netlify/functions';\n import type {\n   PairsResponse,\n   ApiError,\n   Provider,\n"
                },
                {
                    "date": 1755434261997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n import type { Handler } from '@netlify/functions';\n+// \n import type {\n   PairsResponse,\n   ApiError,\n   Provider,\n"
                },
                {
                    "date": 1755434271527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import type { Handler } from '@netlify/functions';\n-// Cannot find module '@netlify/functions' or its corresponding type declarations.\n+// If cannot find module '@netlify/functions' or its corresponding type declarations.\n \n import type {\n   PairsResponse,\n   ApiError,\n"
                },
                {
                    "date": 1755455852593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,417 @@\n+import type { Handler } from '@netlify/functions';\n+import type {\n+  PairsResponse,\n+  ApiError,\n+  Provider,\n+  PoolSummary,\n+  TokenMeta,\n+  Address,\n+} from '../../src/lib/types';\n+import fs from 'fs/promises';\n+import { isGtSupported } from '../shared/dex-allow';\n+import { toGTNetwork, CHAIN_TO_GT_NETWORK, isPriorityChain } from '../shared/chains';\n+\n+const GT_FIXTURE = '../../fixtures/pairs-gt.json';\n+\n+const USE_FIXTURES = process.env.USE_FIXTURES === 'true';\n+const DS_API_BASE = process.env.DS_API_BASE || '';\n+const GT_API_BASE = process.env.GT_API_BASE || '';\n+const DEBUG = process.env.DEBUG_LOGS === 'true';\n+\n+function log(...args: any[]) {\n+  if (DEBUG) console.log('[pairs]', ...args);\n+}\n+\n+function logError(...args: any[]) {\n+  console.error('[pairs]', ...args);\n+}\n+\n+// Map numeric chain IDs from Dexscreener to chain slugs used in the app.\n+const CHAIN_ID_MAP: Record<string, string> = {\n+  '1': 'ethereum',\n+  '56': 'bsc',\n+  '137': 'polygon',\n+  '10': 'optimism',\n+  '42161': 'arbitrum',\n+  '43114': 'avalanche',\n+  '8453': 'base',\n+  '250': 'fantom',\n+  '59144': 'linea',\n+  '534352': 'scroll',\n+  '324': 'zksync',\n+  '5000': 'mantle',\n+  '1284': 'moonbeam',\n+  '1285': 'moonriver',\n+  '25': 'cronos',\n+  '1666600000': 'harmony',\n+  '42220': 'celo',\n+  '1313161554': 'aurora',\n+  '1088': 'metis',\n+  '288': 'boba',\n+  '2222': 'kava',\n+  '100': 'gnosis',\n+  // Add more chain ID mappings as needed\n+  // To a\n+};\n+\n+// Use all supported chains from our comprehensive chain mapping\n+let SUPPORTED_CHAINS: Set<string> | null = null;\n+try {\n+  SUPPORTED_CHAINS = new Set(Object.keys(CHAIN_TO_GT_NETWORK));\n+} catch (err) {\n+  logError('failed to init supported chains', err);\n+}\n+\n+function mapChainId(id: unknown): string {\n+  const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n+  return (key && CHAIN_ID_MAP[key]) || (key ?? 'unknown');\n+}\n+\n+function isValidAddress(addr?: string): addr is string {\n+  return !!addr && /^0x[a-fA-F0-9]{40}$/.test(addr);\n+}\n+\n+function isValidChain(chain?: string): chain is string {\n+  return !!chain;\n+}\n+\n+async function readFixture(path: string): Promise<PairsResponse> {\n+  const url = new URL(path, import.meta.url);\n+  const data = await fs.readFile(url, 'utf8');\n+  return JSON.parse(data) as PairsResponse;\n+}\n+\n+async function fetchJson(url: string): Promise<any> {\n+  const controller = new AbortController();\n+  const id = setTimeout(() => controller.abort(), 3000);\n+  try {\n+    log('fetch', url);\n+    const res = await fetch(url, { signal: controller.signal });\n+    log('status', url, res.status);\n+    if (!res.ok) throw new Error(`status ${res.status}`);\n+    return await res.json();\n+  } catch (err) {\n+    logError('fetch error', url, err);\n+    throw err;\n+  } finally {\n+    clearTimeout(id);\n+  }\n+}\n+\n+export const handler: Handler = async (event) => {\n+  const chain = event.queryStringParameters?.chain;\n+  const address = event.queryStringParameters?.address;\n+  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n+\n+  const headers: Record<string, string> = {\n+    'Content-Type': 'application/json',\n+    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n+    'x-provider': 'none',\n+    'x-fallbacks-tried': '',\n+    'x-items': '0',\n+    'x-gt-network': 'none',\n+  };\n+  const attempted: string[] = [];\n+  let provider: Provider | 'none' = 'none';\n+\n+  if (!SUPPORTED_CHAINS) {\n+    const body: ApiError = { error: 'config_error', provider: 'none' };\n+    logError('config error: supported chains missing');\n+    log('response', event.rawUrl, 500, 0, provider);\n+    return { statusCode: 500, headers, body: JSON.stringify(body) };\n+  }\n+\n+  log('params', { chain, address, forceProvider });\n+\n+  if (!isValidChain(chain) || !isValidAddress(address)) {\n+    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n+    logError('invalid request', { chain, address });\n+    log('response', event.rawUrl, 400, 0, provider);\n+    return { statusCode: 400, headers, body: JSON.stringify(body) };\n+  }\n+  if (!SUPPORTED_CHAINS.has(chain)) {\n+    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n+    logError('unsupported network', chain);\n+    log('response', event.rawUrl, 200, 0, provider);\n+    return { statusCode: 200, headers, body: JSON.stringify(body) };\n+  }\n+\n+  const markUnsupported = () => {\n+    headers['x-gt-network'] = 'none';\n+  };\n+\n+  const gt = toGTNetwork(chain);\n+  if (!gt) {\n+    markUnsupported();\n+  } else {\n+    headers['x-gt-network'] = gt;\n+  }\n+\n+  try {\n+    if (USE_FIXTURES) {\n+      try {\n+        if (forceProvider !== 'gt') {\n+          attempted.push('ds');\n+          // No DS fixture; fall through to error to mimic real behavior\n+          throw new Error('no ds fixture');\n+        }\n+        throw new Error('force gt');\n+      } catch (err) {\n+        logError('ds fixture failed', err);\n+        try {\n+          attempted.push('gt');\n+          const gt = await readFixture(GT_FIXTURE);\n+          provider = 'gt';\n+          headers['x-provider'] = provider;\n+          headers['x-fallbacks-tried'] = attempted.join(',');\n+          headers['x-items'] = String(gt.pools.length);\n+          log('response', event.rawUrl, 200, gt.pools.length, provider);\n+          return { statusCode: 200, headers, body: JSON.stringify(gt) };\n+        } catch (err2) {\n+          logError('gt fixture failed', err2);\n+          headers['x-fallbacks-tried'] = attempted.join(',');\n+          const body: ApiError = { error: 'upstream_error', provider: 'none' };\n+          log('response', event.rawUrl, 500, 0, provider);\n+          return { statusCode: 500, headers, body: JSON.stringify(body) };\n+        }\n+      }\n+    }\n+\n+    // Try Dexscreener (ds) first\n+    if (forceProvider !== 'gt') {\n+      attempted.push('ds');\n+      const dsUrl = `${DS_API_BASE}/dex/tokens/${address}`;\n+      let ds: any;\n+      try {\n+        log('try ds', dsUrl);\n+        ds = await fetchJson(dsUrl);\n+      } catch (err) {\n+        logError('ds request failed', dsUrl, err);\n+        ds = null;\n+      }\n+      if (!ds || !Array.isArray(ds.pairs) || ds.pairs.length === 0) {\n+        throw new Error('empty');\n+      }\n+\n+      const tokenMeta = ds.token || ds.pairs[0]?.baseToken || {};\n+      const token: TokenMeta = {\n+        address: tokenMeta.address || address,\n+        symbol: tokenMeta.symbol || '',\n+        name: tokenMeta.name || '',\n+        icon: tokenMeta.icon || tokenMeta.imageUrl || undefined,\n+      };\n+\n+      const pools: PoolSummary[] = [];\n+      let gtArr: any[] = [];\n+      const needsGtPools = ds.pairs.some((p: any) => {\n+        const addr =\n+          p.pairAddress ||\n+          p.liquidityPoolAddress ||\n+          p.pair?.contract ||\n+          p.pair?.address;\n+        return !isValidAddress(addr);\n+      });\n+      if (needsGtPools) {\n+        if (gt) {\n+          attempted.push('gt');\n+          const gtPoolsUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}/pools`;\n+          try {\n+            const gtPools = await fetchJson(gtPoolsUrl);\n+            gtArr = Array.isArray(gtPools?.data) ? gtPools.data : [];\n+          } catch (err) {\n+            logError('gt pools fetch failed', gtPoolsUrl, err);\n+          }\n+        } else {\n+          markUnsupported();\n+        }\n+      }\n+\n+      for (const p of ds.pairs) {\n+        const chainSlug = mapChainId(p.chainId);\n+        let poolAddr =\n+          p.pairAddress ||\n+          p.liquidityPoolAddress ||\n+          p.pair?.contract ||\n+          p.pair?.address;\n+        let liqUsd = p.liquidity?.usd ?? p.liquidityUsd;\n+        const version = p.dexVersion || p.version;\n+        const pairId = p.pairId || p.pair?.id || p.pairAddress || '';\n+\n+        let match: any;\n+        if (gtArr.length) {\n+          match = gtArr.find((d) => {\n+            const attr = d.attributes || {};\n+            return (\n+              (attr.dex || '').toLowerCase() === (p.dexId || '').toLowerCase() &&\n+              attr.base_token?.symbol === p.baseToken?.symbol &&\n+              attr.quote_token?.symbol === p.quoteToken?.symbol\n+            );\n+          });\n+        }\n+        if (!isValidAddress(poolAddr)) {\n+          if (match && isValidAddress(match.attributes?.pool_address)) {\n+            poolAddr = match.attributes.pool_address;\n+          }\n+        }\n+        if (!isValidAddress(poolAddr)) {\n+          continue;\n+        }\n+        if (match) {\n+          const attr = match.attributes || {};\n+          if (liqUsd === undefined) {\n+            liqUsd = attr.reserve_in_usd ?? attr.reserve_usd;\n+          }\n+        }\n+        pools.push({\n+          pairId: pairId,\n+          dex: p.dexId,\n+          version,\n+          base: p.baseToken?.symbol,\n+          quote: p.quoteToken?.symbol,\n+          chain: chainSlug,\n+          poolAddress: poolAddr as Address,\n+          pairAddress: p.pairAddress,\n+          liqUsd: liqUsd !== undefined ? Number(liqUsd) : undefined,\n+          gtSupported: isGtSupported(p.dexId, version),\n+          labels: Array.isArray(p.labels) ? p.labels : undefined,\n+          baseToken: p.baseToken ? {\n+            address: p.baseToken.address,\n+            symbol: p.baseToken.symbol,\n+            name: p.baseToken.name\n+          } : undefined,\n+          quoteToken: p.quoteToken ? {\n+            address: p.quoteToken.address,\n+            symbol: p.quoteToken.symbol,\n+            name: p.quoteToken.name\n+          } : undefined,\n+          info: p.info ? {\n+            imageUrl: p.info.imageUrl,\n+            header: p.info.header,\n+            openGraph: p.info.openGraph,\n+            description: p.info.description,\n+            websites: Array.isArray(p.info.websites) ? p.info.websites : undefined,\n+            socials: Array.isArray(p.info.socials) ? p.info.socials : undefined,\n+          } : undefined,\n+          priceUsd: p.priceUsd ? Number(p.priceUsd) : undefined,\n+          priceNative: p.priceNative ? Number(p.priceNative) : undefined,\n+          txns: p.txns ? {\n+            m5: p.txns.m5 ? { buys: p.txns.m5.buys || 0, sells: p.txns.m5.sells || 0 } : undefined,\n+            h1: p.txns.h1 ? { buys: p.txns.h1.buys || 0, sells: p.txns.h1.sells || 0 } : undefined,\n+            h6: p.txns.h6 ? { buys: p.txns.h6.buys || 0, sells: p.txns.h6.sells || 0 } : undefined,\n+            h24: p.txns.h24 ? { buys: p.txns.h24.buys || 0, sells: p.txns.h24.sells || 0 } : undefined,\n+          } : undefined,\n+          volume: p.volume ? {\n+            m5: p.volume.m5,\n+            h1: p.volume.h1,\n+            h6: p.volume.h6,\n+            h24: p.volume.h24,\n+          } : undefined,\n+          priceChange: p.priceChange ? {\n+            h1: p.priceChange.h1,\n+            h6: p.priceChange.h6,\n+            h24: p.priceChange.h24,\n+          } : undefined,\n+          liquidity: p.liquidity ? {\n+            usd: p.liquidity.usd,\n+            base: p.liquidity.base,\n+            quote: p.liquidity.quote,\n+          } : undefined,\n+          fdv: p.fdv,\n+          marketCap: p.marketCap,\n+          pairCreatedAt: p.pairCreatedAt,\n+        });\n+      }\n+\n+      pools.sort((a, b) => {\n+        const sup = Number(!!b.gtSupported) - Number(!!a.gtSupported);\n+        if (sup !== 0) return sup;\n+        return (b.liqUsd || 0) - (a.liqUsd || 0);\n+      });\n+\n+      provider = 'ds';\n+      headers['x-provider'] = provider;\n+      headers['x-fallbacks-tried'] = attempted.join(',');\n+      headers['x-items'] = String(pools.length);\n+      log('dexscreener pools', pools.length);\n+      log('response', event.rawUrl, 200, pools.length, provider);\n+      const bodyRes: PairsResponse = { token, pools, provider: 'ds' };\n+      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n+    }\n+\n+    // Try GT provider\n+    throw new Error('force gt');\n+  } catch (err) {\n+    logError('ds branch failed', err);\n+    if (forceProvider === 'ds') {\n+      headers['x-fallbacks-tried'] = attempted.join(',');\n+      const body: ApiError = { error: 'upstream_error', provider: 'none' };\n+      log('response', event.rawUrl, 500, 0, provider);\n+      return { statusCode: 500, headers, body: JSON.stringify(body) };\n+    }\n+    try {\n+      if (!gt) {\n+        markUnsupported();\n+        headers['x-fallbacks-tried'] = attempted.join(',');\n+        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n+        log('response', event.rawUrl, 500, 0, provider);\n+        return { statusCode: 500, headers, body: JSON.stringify(body) };\n+      }\n+      attempted.push('gt');\n+      const tokenUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}`;\n+      const poolsUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}/pools`;\n+      log('try gt', tokenUrl, poolsUrl);\n+      const tokenResp = await fetchJson(tokenUrl);\n+      const poolsResp = await fetchJson(poolsUrl);\n+      const pools: PoolSummary[] = [];\n+      const arr = Array.isArray(poolsResp?.data) ? poolsResp.data : [];\n+      for (const d of arr) {\n+        const attr = d.attributes || {};\n+        const dex = attr.dex || attr.name || '';\n+        const version = attr.version || attr.dex_version;\n+        const liqUsd = attr.reserve_in_usd ?? attr.reserve_usd;\n+        const poolAddr = attr.pool_address;\n+        if (!isValidAddress(poolAddr)) continue;\n+        pools.push({\n+          pairId: d.id,\n+          dex,\n+          version,\n+          base: attr.base_token?.symbol,\n+          quote: attr.quote_token?.symbol,\n+          chain: chain as string,\n+          poolAddress: poolAddr as Address,\n+          liqUsd: liqUsd !== undefined ? Number(liqUsd) : undefined,\n+          gtSupported: isGtSupported(dex, version),\n+        });\n+      }\n+\n+      pools.sort((a, b) => {\n+        const sup = Number(!!b.gtSupported) - Number(!!a.gtSupported);\n+        if (sup !== 0) return sup;\n+        return (b.liqUsd || 0) - (a.liqUsd || 0);\n+      });\n+\n+      const attr = tokenResp.data?.attributes || {};\n+      const token: TokenMeta = {\n+        address: attr.address || address,\n+        symbol: attr.symbol || '',\n+        name: attr.name || '',\n+        icon: attr.image_url || undefined,\n+      };\n+      provider = 'gt';\n+      headers['x-provider'] = provider;\n+      headers['x-fallbacks-tried'] = attempted.join(',');\n+      headers['x-items'] = String(pools.length);\n+      log('gt pools', pools.length);\n+      const bodyRes: PairsResponse = { token, pools, provider: 'gt' };\n+      if (!pools.length) throw new Error('empty');\n+      log('response', event.rawUrl, 200, pools.length, provider);\n+      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n+    } catch (err) {\n+      logError('gt branch failed', err);\n+      headers['x-fallbacks-tried'] = attempted.join(',');\n+      const body: ApiError = { error: 'upstream_error', provider: 'none' };\n+      log('response', event.rawUrl, 500, 0, provider);\n+      return { statusCode: 500, headers, body: JSON.stringify(body) };\n+    }\n+  }\n+};\n"
                }
            ],
            "date": 1755434210881,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type {\n  PairsResponse,\n  ApiError,\n  Provider,\n  PoolSummary,\n  TokenMeta,\n  Address,\n} from '../../src/lib/types';\nimport fs from 'fs/promises';\nimport { isGtSupported } from '../shared/dex-allow';\nimport { toGTNetwork } from '../shared/chains';\n\nconst GT_FIXTURE = '../../fixtures/pairs-gt.json';\n\nconst USE_FIXTURES = process.env.USE_FIXTURES === 'true';\nconst DS_API_BASE = process.env.DS_API_BASE || '';\nconst GT_API_BASE = process.env.GT_API_BASE || '';\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[pairs]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[pairs]', ...args);\n}\n\n// Map numeric chain IDs from Dexscreener to chain slugs used in the app.\nconst CHAIN_ID_MAP: Record<string, string> = {\n  '1': 'ethereum',\n  '56': 'bsc',\n  '137': 'polygon',\n  '10': 'optimism',\n  '42161': 'arbitrum',\n  '43114': 'avalanche',\n  '8453': 'base',\n};\n\nlet SUPPORTED_CHAINS: Set<string> | null = null;\ntry {\n  SUPPORTED_CHAINS = new Set(Object.values(CHAIN_ID_MAP));\n} catch (err) {\n  logError('failed to init supported chains', err);\n}\n\nfunction mapChainId(id: unknown): string {\n  const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n  return (key && CHAIN_ID_MAP[key]) || (key ?? 'unknown');\n}\n\nfunction isValidAddress(addr?: string): addr is string {\n  return !!addr && /^0x[a-fA-F0-9]{40}$/.test(addr);\n}\n\nfunction isValidChain(chain?: string): chain is string {\n  return !!chain;\n}\n\nasync function readFixture(path: string): Promise<PairsResponse> {\n  const url = new URL(path, import.meta.url);\n  const data = await fs.readFile(url, 'utf8');\n  return JSON.parse(data) as PairsResponse;\n}\n\nasync function fetchJson(url: string): Promise<any> {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), 3000);\n  try {\n    log('fetch', url);\n    const res = await fetch(url, { signal: controller.signal });\n    log('status', url, res.status);\n    if (!res.ok) throw new Error(`status ${res.status}`);\n    return await res.json();\n  } catch (err) {\n    logError('fetch error', url, err);\n    throw err;\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nexport const handler: Handler = async (event) => {\n  const chain = event.queryStringParameters?.chain;\n  const address = event.queryStringParameters?.address;\n  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n    'x-gt-network': 'none',\n  };\n  const attempted: string[] = [];\n  let provider: Provider | 'none' = 'none';\n\n  if (!SUPPORTED_CHAINS) {\n    const body: ApiError = { error: 'config_error', provider: 'none' };\n    logError('config error: supported chains missing');\n    log('response', event.rawUrl, 500, 0, provider);\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n\n  log('params', { chain, address, forceProvider });\n\n  if (!isValidChain(chain) || !isValidAddress(address)) {\n    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n    logError('invalid request', { chain, address });\n    log('response', event.rawUrl, 400, 0, provider);\n    return { statusCode: 400, headers, body: JSON.stringify(body) };\n  }\n  if (!SUPPORTED_CHAINS.has(chain)) {\n    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n    logError('unsupported network', chain);\n    log('response', event.rawUrl, 200, 0, provider);\n    return { statusCode: 200, headers, body: JSON.stringify(body) };\n  }\n\n  const markUnsupported = () => {\n    headers['x-gt-network'] = 'none';\n  };\n\n  const gt = toGTNetwork(chain);\n  if (!gt) {\n    markUnsupported();\n  } else {\n    headers['x-gt-network'] = gt;\n  }\n\n  try {\n    if (USE_FIXTURES) {\n      try {\n        if (forceProvider !== 'gt') {\n          attempted.push('ds');\n          // No DS fixture; fall through to error to mimic real behavior\n          throw new Error('no ds fixture');\n        }\n        throw new Error('force gt');\n      } catch (err) {\n        logError('ds fixture failed', err);\n        try {\n          attempted.push('gt');\n          const gt = await readFixture(GT_FIXTURE);\n          provider = 'gt';\n          headers['x-provider'] = provider;\n          headers['x-fallbacks-tried'] = attempted.join(',');\n          headers['x-items'] = String(gt.pools.length);\n          log('response', event.rawUrl, 200, gt.pools.length, provider);\n          return { statusCode: 200, headers, body: JSON.stringify(gt) };\n        } catch (err2) {\n          logError('gt fixture failed', err2);\n          headers['x-fallbacks-tried'] = attempted.join(',');\n          const body: ApiError = { error: 'upstream_error', provider: 'none' };\n          log('response', event.rawUrl, 500, 0, provider);\n          return { statusCode: 500, headers, body: JSON.stringify(body) };\n        }\n      }\n    }\n\n    // Try Dexscreener (ds) first\n    if (forceProvider !== 'gt') {\n      attempted.push('ds');\n      const dsUrl = `${DS_API_BASE}/dex/tokens/${address}`;\n      let ds: any;\n      try {\n        log('try ds', dsUrl);\n        ds = await fetchJson(dsUrl);\n      } catch (err) {\n        logError('ds request failed', dsUrl, err);\n        ds = null;\n      }\n      if (!ds || !Array.isArray(ds.pairs) || ds.pairs.length === 0) {\n        throw new Error('empty');\n      }\n\n      const tokenMeta = ds.token || ds.pairs[0]?.baseToken || {};\n      const token: TokenMeta = {\n        address: tokenMeta.address || address,\n        symbol: tokenMeta.symbol || '',\n        name: tokenMeta.name || '',\n        icon: tokenMeta.icon || tokenMeta.imageUrl || undefined,\n      };\n\n      const pools: PoolSummary[] = [];\n      let gtArr: any[] = [];\n      const needsGtPools = ds.pairs.some((p: any) => {\n        const addr =\n          p.pairAddress ||\n          p.liquidityPoolAddress ||\n          p.pair?.contract ||\n          p.pair?.address;\n        return !isValidAddress(addr);\n      });\n      if (needsGtPools) {\n        if (gt) {\n          attempted.push('gt');\n          const gtPoolsUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}/pools`;\n          try {\n            const gtPools = await fetchJson(gtPoolsUrl);\n            gtArr = Array.isArray(gtPools?.data) ? gtPools.data : [];\n          } catch (err) {\n            logError('gt pools fetch failed', gtPoolsUrl, err);\n          }\n        } else {\n          markUnsupported();\n        }\n      }\n\n      for (const p of ds.pairs) {\n        const chainSlug = mapChainId(p.chainId);\n        let poolAddr =\n          p.pairAddress ||\n          p.liquidityPoolAddress ||\n          p.pair?.contract ||\n          p.pair?.address;\n        let liqUsd = p.liquidity?.usd ?? p.liquidityUsd;\n        const version = p.dexVersion || p.version;\n        const pairId = p.pairId || p.pair?.id || p.pairAddress || '';\n\n        let match: any;\n        if (gtArr.length) {\n          match = gtArr.find((d) => {\n            const attr = d.attributes || {};\n            return (\n              (attr.dex || '').toLowerCase() === (p.dexId || '').toLowerCase() &&\n              attr.base_token?.symbol === p.baseToken?.symbol &&\n              attr.quote_token?.symbol === p.quoteToken?.symbol\n            );\n          });\n        }\n        if (!isValidAddress(poolAddr)) {\n          if (match && isValidAddress(match.attributes?.pool_address)) {\n            poolAddr = match.attributes.pool_address;\n          }\n        }\n        if (!isValidAddress(poolAddr)) {\n          continue;\n        }\n        if (match) {\n          const attr = match.attributes || {};\n          if (liqUsd === undefined) {\n            liqUsd = attr.reserve_in_usd ?? attr.reserve_usd;\n          }\n        }\n        pools.push({\n          pairId: pairId,\n          dex: p.dexId,\n          version,\n          base: p.baseToken?.symbol,\n          quote: p.quoteToken?.symbol,\n          chain: chainSlug,\n          poolAddress: poolAddr as Address,\n          pairAddress: p.pairAddress,\n          liqUsd: liqUsd !== undefined ? Number(liqUsd) : undefined,\n          gtSupported: isGtSupported(p.dexId, version),\n          labels: Array.isArray(p.labels) ? p.labels : undefined,\n          baseToken: p.baseToken ? {\n            address: p.baseToken.address,\n            symbol: p.baseToken.symbol,\n            name: p.baseToken.name\n          } : undefined,\n          quoteToken: p.quoteToken ? {\n            address: p.quoteToken.address,\n            symbol: p.quoteToken.symbol,\n            name: p.quoteToken.name\n          } : undefined,\n          info: p.info ? {\n            imageUrl: p.info.imageUrl,\n            header: p.info.header,\n            openGraph: p.info.openGraph,\n            description: p.info.description,\n            websites: Array.isArray(p.info.websites) ? p.info.websites : undefined,\n            socials: Array.isArray(p.info.socials) ? p.info.socials : undefined,\n          } : undefined,\n          priceUsd: p.priceUsd ? Number(p.priceUsd) : undefined,\n          priceNative: p.priceNative ? Number(p.priceNative) : undefined,\n          txns: p.txns ? {\n            m5: p.txns.m5 ? { buys: p.txns.m5.buys || 0, sells: p.txns.m5.sells || 0 } : undefined,\n            h1: p.txns.h1 ? { buys: p.txns.h1.buys || 0, sells: p.txns.h1.sells || 0 } : undefined,\n            h6: p.txns.h6 ? { buys: p.txns.h6.buys || 0, sells: p.txns.h6.sells || 0 } : undefined,\n            h24: p.txns.h24 ? { buys: p.txns.h24.buys || 0, sells: p.txns.h24.sells || 0 } : undefined,\n          } : undefined,\n          volume: p.volume ? {\n            m5: p.volume.m5,\n            h1: p.volume.h1,\n            h6: p.volume.h6,\n            h24: p.volume.h24,\n          } : undefined,\n          priceChange: p.priceChange ? {\n            h1: p.priceChange.h1,\n            h6: p.priceChange.h6,\n            h24: p.priceChange.h24,\n          } : undefined,\n          liquidity: p.liquidity ? {\n            usd: p.liquidity.usd,\n            base: p.liquidity.base,\n            quote: p.liquidity.quote,\n          } : undefined,\n          fdv: p.fdv,\n          marketCap: p.marketCap,\n          pairCreatedAt: p.pairCreatedAt,\n        });\n      }\n\n      pools.sort((a, b) => {\n        const sup = Number(!!b.gtSupported) - Number(!!a.gtSupported);\n        if (sup !== 0) return sup;\n        return (b.liqUsd || 0) - (a.liqUsd || 0);\n      });\n\n      provider = 'ds';\n      headers['x-provider'] = provider;\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      headers['x-items'] = String(pools.length);\n      log('dexscreener pools', pools.length);\n      log('response', event.rawUrl, 200, pools.length, provider);\n      const bodyRes: PairsResponse = { token, pools, provider: 'ds' };\n      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n    }\n\n    // Try GT provider\n    throw new Error('force gt');\n  } catch (err) {\n    logError('ds branch failed', err);\n    if (forceProvider === 'ds') {\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      const body: ApiError = { error: 'upstream_error', provider: 'none' };\n      log('response', event.rawUrl, 500, 0, provider);\n      return { statusCode: 500, headers, body: JSON.stringify(body) };\n    }\n    try {\n      if (!gt) {\n        markUnsupported();\n        headers['x-fallbacks-tried'] = attempted.join(',');\n        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n        log('response', event.rawUrl, 500, 0, provider);\n        return { statusCode: 500, headers, body: JSON.stringify(body) };\n      }\n      attempted.push('gt');\n      const tokenUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}`;\n      const poolsUrl = `${GT_API_BASE}/networks/${gt}/tokens/${address}/pools`;\n      log('try gt', tokenUrl, poolsUrl);\n      const tokenResp = await fetchJson(tokenUrl);\n      const poolsResp = await fetchJson(poolsUrl);\n      const pools: PoolSummary[] = [];\n      const arr = Array.isArray(poolsResp?.data) ? poolsResp.data : [];\n      for (const d of arr) {\n        const attr = d.attributes || {};\n        const dex = attr.dex || attr.name || '';\n        const version = attr.version || attr.dex_version;\n        const liqUsd = attr.reserve_in_usd ?? attr.reserve_usd;\n        const poolAddr = attr.pool_address;\n        if (!isValidAddress(poolAddr)) continue;\n        pools.push({\n          pairId: d.id,\n          dex,\n          version,\n          base: attr.base_token?.symbol,\n          quote: attr.quote_token?.symbol,\n          chain: chain as string,\n          poolAddress: poolAddr as Address,\n          liqUsd: liqUsd !== undefined ? Number(liqUsd) : undefined,\n          gtSupported: isGtSupported(dex, version),\n        });\n      }\n\n      pools.sort((a, b) => {\n        const sup = Number(!!b.gtSupported) - Number(!!a.gtSupported);\n        if (sup !== 0) return sup;\n        return (b.liqUsd || 0) - (a.liqUsd || 0);\n      });\n\n      const attr = tokenResp.data?.attributes || {};\n      const token: TokenMeta = {\n        address: attr.address || address,\n        symbol: attr.symbol || '',\n        name: attr.name || '',\n        icon: attr.image_url || undefined,\n      };\n      provider = 'gt';\n      headers['x-provider'] = provider;\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      headers['x-items'] = String(pools.length);\n      log('gt pools', pools.length);\n      const bodyRes: PairsResponse = { token, pools, provider: 'gt' };\n      if (!pools.length) throw new Error('empty');\n      log('response', event.rawUrl, 200, pools.length, provider);\n      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n    } catch (err) {\n      logError('gt branch failed', err);\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      const body: ApiError = { error: 'upstream_error', provider: 'none' };\n      log('response', event.rawUrl, 500, 0, provider);\n      return { statusCode: 500, headers, body: JSON.stringify(body) };\n    }\n  }\n};\n"
        }
    ]
}