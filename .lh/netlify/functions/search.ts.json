{
    "sourceFile": "netlify/functions/search.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1755434210881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755437786033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n   '10': 'optimism',\n   '42161': 'arbitrum',\n   '43114': 'avalanche',\n   '8453': 'base',\n+  // \n };\n \n function mapChainId(id: unknown): string {\n   const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n"
                },
                {
                    "date": 1755437795222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,8 @@\n   '10': 'optimism',\n   '42161': 'arbitrum',\n   '43114': 'avalanche',\n   '8453': 'base',\n-\n };\n \n function mapChainId(id: unknown): string {\n   const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n"
                },
                {
                    "date": 1755455927454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,13 @@\n   'solana': 'solana',\n   'aptos': 'aptos',\n   'sui': 'sui',\n   'sei': 'sei', \n-  \n+  'manta': 'manta',\n+  'lightlink': 'lightlink',\n+  'stepnetwork': 'step-network',\n+  'starknet': 'starknet-alpha',\n+  'neonevm': 'neon-evm',\n };\n \n function mapChainId(id: unknown): string {\n   const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n"
                }
            ],
            "date": 1755434210881,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type {\n  SearchResponse,\n  Provider,\n  SearchTokenSummary,\n  PoolSummary,\n  ApiError,\n} from '../../src/lib/types';\nimport { isGtSupported } from '../shared/dex-allow';\nimport fs from 'fs/promises';\n\nconst GT_FIXTURE = '../../fixtures/search-gt.json';\nconst DS_FIXTURE = '../../fixtures/search-ds.json';\n\nconst USE_FIXTURES = process.env.USE_FIXTURES === 'true';\nconst DS_API_BASE = process.env.DS_API_BASE || '';\nconst GT_API_BASE = process.env.GT_API_BASE || '';\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[search]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[search]', ...args);\n}\n\nasync function readFixture(path: string): Promise<SearchResponse> {\n  const url = new URL(path, import.meta.url);\n  const data = await fs.readFile(url, 'utf8');\n  return JSON.parse(data) as SearchResponse;\n}\n\nasync function fetchJson(url: string): Promise<any> {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), 3000);\n  try {\n    const res = await fetch(url, { signal: controller.signal });\n    if (!res.ok) throw new Error('status');\n    return await res.json();\n  } catch (err) {\n    logError('fetch error', url, err);\n    throw err;\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nconst CHAIN_ID_MAP: Record<string, string> = {\n  '1': 'ethereum',\n  '56': 'bsc',\n  '137': 'polygon',\n  '10': 'optimism',\n  '42161': 'arbitrum',\n  '43114': 'avalanche',\n  '8453': 'base',\n};\n\nfunction mapChainId(id: unknown): string {\n  const key = typeof id === 'number' ? String(id) : (id as string | undefined);\n  return (key && CHAIN_ID_MAP[key]) || (key ?? 'unknown');\n}\n\nexport const handler: Handler = async (event) => {\n  const query =\n    event.queryStringParameters?.query ||\n    event.queryStringParameters?.address ||\n    '';\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n  };\n\n  const attempted: string[] = [];\n  let provider: Provider | 'none' = 'none';\n  try {\n    if (USE_FIXTURES) {\n      try {\n        const ds = await readFixture(DS_FIXTURE);\n        ds.query = query;\n        headers['x-provider'] = ds.results[0]?.provider || 'ds';\n        headers['x-items'] = String(ds.results.length);\n        return { statusCode: 200, headers, body: JSON.stringify(ds) };\n      } catch (err) {\n        logError('fixture read failed', err);\n      }\n    }\n\n    try {\n      attempted.push('ds');\n      const ds = await fetchJson(`${DS_API_BASE}/dex/tokens/${query}`);\n      const pairs = Array.isArray(ds?.pairs) ? ds.pairs : [];\n      if (pairs.length) {\n        const tokenMeta = ds.token || pairs[0]?.baseToken || {};\n        // Extract info from the first pair (which has the most complete data)\n        const firstPairInfo = pairs[0]?.info || {};\n        const pools: PoolSummary[] = [];\n      let totalLiq = 0;\n      let totalVol = 0;\n      let bestLiq = 0;\n      let bestPrice = 0;\n      let gtPools = 0;\n      const chainTotals: Record<string, number> = {};\n      for (const p of pairs) {\n        const chainSlug = mapChainId(p.chainId);\n        const liq =\n          p.liquidity?.usd !== undefined\n            ? Number(p.liquidity.usd)\n            : p.liquidityUsd !== undefined\n            ? Number(p.liquidityUsd)\n            : 0;\n        const vol = p.volume?.h24 !== undefined ? Number(p.volume.h24) : 0;\n        const price = p.priceUsd !== undefined ? Number(p.priceUsd) : undefined;\n        const gt = isGtSupported(p.dexId, p.dexVersion || p.version);\n        pools.push({\n          pairId: p.pairId || p.pairAddress,\n          dex: p.dexId,\n          version: p.dexVersion || p.version,\n          base: p.baseToken?.symbol,\n          quote: p.quoteToken?.symbol,\n          chain: chainSlug,\n          poolAddress: p.pairAddress,\n          liqUsd: liq,\n          gtSupported: gt,\n          labels: Array.isArray(p.labels) ? p.labels : undefined,\n          info: p.info ? {\n            imageUrl: p.info.imageUrl,\n            header: p.info.header,\n            openGraph: p.info.openGraph,\n            websites: Array.isArray(p.info.websites) ? p.info.websites : undefined,\n            socials: Array.isArray(p.info.socials) ? p.info.socials : undefined,\n          } : undefined,\n          priceUsd: price,\n          priceNative: p.priceNative ? Number(p.priceNative) : undefined,\n          txns: p.txns ? {\n            m5: p.txns.m5 ? { buys: p.txns.m5.buys || 0, sells: p.txns.m5.sells || 0 } : undefined,\n            h1: p.txns.h1 ? { buys: p.txns.h1.buys || 0, sells: p.txns.h1.sells || 0 } : undefined,\n            h6: p.txns.h6 ? { buys: p.txns.h6.buys || 0, sells: p.txns.h6.sells || 0 } : undefined,\n            h24: p.txns.h24 ? { buys: p.txns.h24.buys || 0, sells: p.txns.h24.sells || 0 } : undefined,\n          } : undefined,\n          volume: p.volume ? {\n            m5: p.volume.m5,\n            h1: p.volume.h1,\n            h6: p.volume.h6,\n            h24: p.volume.h24,\n          } : undefined,\n          priceChange: p.priceChange ? {\n            h1: p.priceChange.h1,\n            h6: p.priceChange.h6,\n            h24: p.priceChange.h24,\n          } : undefined,\n          liquidity: p.liquidity ? {\n            usd: p.liquidity.usd,\n            base: p.liquidity.base,\n            quote: p.liquidity.quote,\n          } : undefined,\n          fdv: p.fdv,\n          marketCap: p.marketCap,\n          pairCreatedAt: p.pairCreatedAt,\n        });\n        totalLiq += liq;\n        totalVol += vol;\n        if (price !== undefined && liq > bestLiq) {\n          bestLiq = liq;\n          bestPrice = price;\n        }\n        chainTotals[chainSlug] = (chainTotals[chainSlug] || 0) + liq;\n        if (gt) gtPools++;\n      }\n      const chainEntries = Object.entries(chainTotals).sort((a, b) => b[1] - a[1]);\n      const chainIcons = chainEntries.slice(0, 3).map(([c]) => c);\n      const summary: SearchTokenSummary = {\n        address: tokenMeta.address || query,\n        symbol: tokenMeta.symbol || '',\n        name: tokenMeta.name || '',\n        icon: tokenMeta.icon || tokenMeta.imageUrl || undefined,\n        priceUsd: bestPrice,\n        liqUsd: totalLiq,\n        vol24hUsd: totalVol,\n        chainIcons,\n        poolCount: pools.length,\n        gtSupported: gtPools > 0,\n        provider: 'ds',\n        chainCount: chainEntries.length,\n        pools,\n      };\n      const bodyRes: SearchResponse = { query, results: [summary] };\n      provider = 'ds';\n      headers['x-provider'] = provider;\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      headers['x-items'] = '1';\n      log('response', event.rawUrl, 200, 1, provider);\n      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n    }\n    throw new Error('empty');\n    } catch (err) {\n      logError('ds branch failed', err);\n    }\n\n    try {\n      attempted.push('gt');\n      const gt = await fetchJson(`${GT_API_BASE}/search/pairs?query=${query}`);\n      const arr = Array.isArray(gt?.data) ? gt.data : [];\n    if (!arr.length) throw new Error('empty');\n    const pools: PoolSummary[] = [];\n    let totalLiq = 0;\n    let totalVol = 0;\n    let bestLiq = 0;\n    let bestPrice = 0;\n    let gtPools = 0;\n    const chainTotals: Record<string, number> = {};\n    let tokenMeta: any = {};\n    for (const d of arr) {\n      const attr = d.attributes || {};\n      const token = attr.base_token || attr.token || {};\n      tokenMeta.address = token.address || query;\n      tokenMeta.symbol = token.symbol || '';\n      tokenMeta.name = token.name || '';\n      tokenMeta.icon = token.image_url || undefined;\n      const chainSlug = attr.network || 'unknown';\n      const liq =\n        attr.liquidity_usd !== undefined\n          ? Number(attr.liquidity_usd)\n          : attr.reserve_in_usd !== undefined\n          ? Number(attr.reserve_in_usd)\n          : attr.reserve_usd !== undefined\n          ? Number(attr.reserve_usd)\n          : 0;\n      const vol = attr.volume_24h_usd !== undefined ? Number(attr.volume_24h_usd) : 0;\n      const price =\n        attr.base_token_price_usd !== undefined\n          ? Number(attr.base_token_price_usd)\n          : attr.price_usd !== undefined\n          ? Number(attr.price_usd)\n          : undefined;\n      const gt = isGtSupported(attr.dex || attr.name, attr.version || attr.dex_version);\n      pools.push({\n        pairId: d.id,\n        dex: attr.dex || attr.name || '',\n        version: attr.version || attr.dex_version,\n        base: attr.base_token?.symbol,\n        quote: attr.quote_token?.symbol,\n        chain: chainSlug,\n        poolAddress: attr.pool_address || d.id,\n        liqUsd: liq,\n        gtSupported: gt,\n      });\n      totalLiq += liq;\n      totalVol += vol;\n      if (price !== undefined && liq > bestLiq) {\n        bestLiq = liq;\n        bestPrice = price;\n      }\n      chainTotals[chainSlug] = (chainTotals[chainSlug] || 0) + liq;\n      if (gt) gtPools++;\n    }\n    const chainEntries = Object.entries(chainTotals).sort((a, b) => b[1] - a[1]);\n    const chainIcons = chainEntries.slice(0, 3).map(([c]) => c);\n    const summary: SearchTokenSummary = {\n      address: tokenMeta.address || query,\n      symbol: tokenMeta.symbol || '',\n      name: tokenMeta.name || '',\n      icon: tokenMeta.icon,\n      priceUsd: bestPrice,\n      liqUsd: totalLiq,\n      vol24hUsd: totalVol,\n      chainIcons,\n      poolCount: pools.length,\n      gtSupported: gtPools > 0,\n      provider: 'gt',\n      chainCount: chainEntries.length,\n      pools,\n    };\n    const bodyRes: SearchResponse = { query, results: [summary] };\n    provider = 'gt';\n    headers['x-provider'] = provider;\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    headers['x-items'] = '1';\n    log('response', event.rawUrl, 200, 1, provider);\n    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n    } catch (err) {\n      logError('gt branch failed', err);\n    }\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    const empty: SearchResponse = { query, results: [] };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(empty) };\n  } catch (err) {\n    logError('handler error', err);\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    const body: ApiError = { error: 'internal_error', provider: 'none' };\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n};\n\n"
        }
    ]
}