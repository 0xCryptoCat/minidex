{
    "sourceFile": "netlify/functions/token.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755456083081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755456083081,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type { TokenResponse, ApiError } from '../../src/lib/types';\nimport { isGtSupported } from '../shared/dex-allow';\nimport { toGTNetwork, CHAIN_TO_GT_NETWORK } from '../shared/chains';\nimport { getJson } from '../shared/http';\n\nconst CG_API_BASE = process.env.COINGECKO_API_BASE || '';\nconst CG_API_KEY = process.env.COINGECKO_API_KEY || '';\nconst rawDs = process.env.DS_API_BASE || 'https://api.dexscreener.com';\nconst dsBase = rawDs.replace(/\\/+$/, '').replace(/\\/latest$/, '');\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[token]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[token]', ...args);\n}\n\nfunction isValidChain(chain?: string): chain is string {\n  return !!chain;\n}\n\nfunction isValidAddress(addr?: string): addr is string {\n  return !!addr && /^0x[a-fA-F0-9]{40}$/.test(addr);\n}\n\nasync function fetchCgToken(chain: string, address: string): Promise<any> {\n  const urls = [\n    `${CG_API_BASE}/token-data/${chain}/${address}`,\n    `${CG_API_BASE}/tokens-data?network=${chain}&contract_addresses=${address}`,\n  ];\n  for (const url of urls) {\n    try {\n      const res = await fetch(url, {\n        headers: { 'x-cg-pro-api-key': CG_API_KEY },\n      });\n      if (res.ok) return await res.json();\n    } catch (err) {\n      logError('cg token fetch failed', url, err);\n      // try next\n    }\n  }\n  throw new Error('cg_error');\n}\n\nexport const handler: Handler = async (event) => {\n  const chain = event.queryStringParameters?.chain;\n  const address = event.queryStringParameters?.address;\n  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n    'x-ds-info': 'missing',\n  };\n  const attempted: string[] = [];\n\n  if (!isValidChain(chain) || !isValidAddress(address)) {\n    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n    log('response', event.rawUrl, 400, 0, 'none');\n    return { statusCode: 400, headers, body: JSON.stringify(body) };\n  }\n  if (!SUPPORTED_CHAINS.includes(chain)) {\n    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(body) };\n  }\n\n  log('params', { chain, address });\n\n  try {\n    let info: any = undefined;\n    let pools: any[] = [];\n    let provider: 'ds' | 'cg' | undefined;\n    const kpis: any = {};\n\n    if (dsBase) {\n      try {\n        attempted.push('ds');\n        const res = await fetch(`${dsBase}/token-pairs/v1/${chain}/${address.toLowerCase()}`);\n        if (res.ok) {\n          const ds = await res.json();\n          info = ds.info;\n          headers['x-ds-info'] = info ? 'present' : 'missing';\n          pools = Array.isArray(ds.pairs)\n            ? ds.pairs.map((p: any) => {\n                const tx = p.txns || {};\n                const mapTx = (t: any) =>\n                  t ? { buys: Number(t.buys || 0), sells: Number(t.sells || 0) } : undefined;\n                return {\n                  pairId: p.pairId || p.pairAddress,\n                  dex: p.dexId,\n                  version: p.dexVersion || p.version,\n                  chain,\n                  pairAddress: p.pairAddress,\n                  pairUrl: p.url,\n                  baseToken: {\n                    address: p.baseToken?.address,\n                    symbol: p.baseToken?.symbol,\n                    name: p.baseToken?.name,\n                  },\n                  quoteToken: {\n                    address: p.quoteToken?.address,\n                    symbol: p.quoteToken?.symbol,\n                    name: p.quoteToken?.name,\n                  },\n                  priceNative:\n                    p.priceNative !== undefined\n                      ? Number(p.priceNative)\n                      : p.price_native !== undefined\n                      ? Number(p.price_native)\n                      : undefined,\n                  priceUsd:\n                    p.priceUsd !== undefined\n                      ? Number(p.priceUsd)\n                      : p.price_usd !== undefined\n                      ? Number(p.price_usd)\n                      : undefined,\n                  liquidity: {\n                    usd:\n                      p.liquidity?.usd !== undefined\n                        ? Number(p.liquidity.usd)\n                        : p.liquidityUsd !== undefined\n                        ? Number(p.liquidityUsd)\n                        : undefined,\n                    base: p.liquidity?.base !== undefined ? Number(p.liquidity.base) : undefined,\n                    quote: p.liquidity?.quote !== undefined ? Number(p.liquidity.quote) : undefined,\n                  },\n                  fdv: p.fdv !== undefined ? Number(p.fdv) : undefined,\n                  marketCap: p.marketCap !== undefined ? Number(p.marketCap) : undefined,\n                  labels: Array.isArray(p.labels) ? p.labels : undefined,\n                  txns: {\n                    m5: mapTx(tx.m5),\n                    h1: mapTx(tx.h1),\n                    h6: mapTx(tx.h6),\n                    h24: mapTx(tx.h24),\n                  },\n                  volume: {\n                    m5: p.volume?.m5 !== undefined ? Number(p.volume.m5) : undefined,\n                    h1: p.volume?.h1 !== undefined ? Number(p.volume.h1) : undefined,\n                    h6: p.volume?.h6 !== undefined ? Number(p.volume.h6) : undefined,\n                    h24: p.volume?.h24 !== undefined ? Number(p.volume.h24) : undefined,\n                  },\n                  priceChange: {\n                    m5: p.priceChange?.m5 !== undefined ? Number(p.priceChange.m5) : undefined,\n                    h1: p.priceChange?.h1 !== undefined ? Number(p.priceChange.h1) : undefined,\n                    h6: p.priceChange?.h6 !== undefined ? Number(p.priceChange.h6) : undefined,\n                    h24: p.priceChange?.h24 !== undefined ? Number(p.priceChange.h24) : undefined,\n                  },\n                  pairCreatedAt: p.pairCreatedAt ? Number(p.pairCreatedAt) : undefined,\n                  gtSupported: isGtSupported(p.dexId, p.dexVersion || p.version),\n                };\n              })\n            : [];\n          provider = 'ds';\n          log('ds token');\n        }\n\n        if (!pools.length) {\n          attempted.push('ds-search');\n          const search = await getJson(`${dsBase}/latest/dex/search?q=${address}`);\n          const list = Array.isArray(search?.pairs)\n            ? search.pairs\n            : Array.isArray(search)\n            ? search\n            : [];\n          const match = list.find((p: any) => {\n            const b = p.baseToken?.address?.toLowerCase();\n            const q = p.quoteToken?.address?.toLowerCase();\n            return b === address.toLowerCase() || q === address.toLowerCase();\n          });\n          if (match) {\n            const tx = match.txns || {};\n            const mapTx = (t: any) =>\n              t ? { buys: Number(t.buys || 0), sells: Number(t.sells || 0) } : undefined;\n            pools = [\n              {\n                pairId: match.pairId || match.pairAddress,\n                dex: match.dexId,\n                version: match.dexVersion || match.version,\n                chain,\n                pairAddress: match.pairAddress,\n                pairUrl: match.url,\n                baseToken: {\n                  address: match.baseToken?.address,\n                  symbol: match.baseToken?.symbol,\n                  name: match.baseToken?.name,\n                },\n                quoteToken: {\n                  address: match.quoteToken?.address,\n                  symbol: match.quoteToken?.symbol,\n                  name: match.quoteToken?.name,\n                },\n                priceNative: match.priceNative ? Number(match.priceNative) : undefined,\n                priceUsd: match.priceUsd ? Number(match.priceUsd) : undefined,\n                liquidity: {\n                  usd: match.liquidityUsd ? Number(match.liquidityUsd) : undefined,\n                  base: undefined,\n                  quote: undefined,\n                },\n                fdv: match.fdv ? Number(match.fdv) : undefined,\n                marketCap: match.marketCap ? Number(match.marketCap) : undefined,\n                labels: Array.isArray(match.labels) ? match.labels : undefined,\n                txns: {\n                  m5: mapTx(tx.m5),\n                  h1: mapTx(tx.h1),\n                  h6: mapTx(tx.h6),\n                  h24: mapTx(tx.h24),\n                },\n                volume: {\n                  m5: match.volume?.m5 !== undefined ? Number(match.volume.m5) : undefined,\n                  h1: match.volume?.h1 !== undefined ? Number(match.volume.h1) : undefined,\n                  h6: match.volume?.h6 !== undefined ? Number(match.volume.h6) : undefined,\n                  h24: match.volume?.h24 !== undefined ? Number(match.volume.h24) : undefined,\n                },\n                priceChange: {\n                  m5: match.priceChange?.m5 !== undefined ? Number(match.priceChange.m5) : undefined,\n                  h1: match.priceChange?.h1 !== undefined ? Number(match.priceChange.h1) : undefined,\n                  h6: match.priceChange?.h6 !== undefined ? Number(match.priceChange.h6) : undefined,\n                  h24: match.priceChange?.h24 !== undefined ? Number(match.priceChange.h24) : undefined,\n                },\n                pairCreatedAt: match.pairCreatedAt ? Number(match.pairCreatedAt) : undefined,\n                gtSupported: isGtSupported(match.dexId, match.dexVersion || match.version),\n              },\n            ];\n          }\n        }\n      } catch (err) {\n        logError('ds token fetch failed', err);\n      }\n    }\n\n    if (!pools.length) {\n      const gtNet = toGTNetwork(chain);\n      if (gtNet) {\n        attempted.push('gt');\n        try {\n          const gt = await getJson(\n            `https://api.geckoterminal.com/api/v2/networks/${gtNet}/tokens/${address.toLowerCase()}/pools`\n          );\n          const attrs = gt?.data?.[0]?.attributes;\n          if (attrs) {\n            info = info || {};\n            info.baseToken = info.baseToken || { symbol: attrs.base_token_symbol };\n            info.quoteToken = info.quoteToken || { symbol: attrs.quote_token_symbol };\n          }\n        } catch (err) {\n          logError('gt token fetch failed', err);\n        }\n      }\n\n      if (CG_API_BASE && CG_API_KEY) {\n        attempted.push('cg-info');\n        try {\n          const cgInfo = await getJson(\n            `${CG_API_BASE}/token-info-contract-address?chain=${chain}&address=${address.toLowerCase()}`,\n            { headers: { 'x-cg-pro-api-key': CG_API_KEY } }\n          );\n          const attr = cgInfo?.data?.attributes || cgInfo?.data || cgInfo;\n          if (attr) {\n            info = info || {};\n            if (!info.symbol && attr.symbol) info.symbol = attr.symbol;\n            if (!info.name && attr.name) info.name = attr.name;\n            if (!info.imageUrl && (attr.image || attr.logo || attr.image_url))\n              info.imageUrl = attr.image || attr.logo || attr.image_url;\n          }\n        } catch (err) {\n          logError('cg info fetch failed', err);\n        }\n      }\n    }\n\n    if (pools.length) {\n      const first = pools[0];\n      kpis.priceUsd = first.priceUsd;\n      kpis.priceNative = first.priceNative;\n      kpis.liqUsd = first.liquidity?.usd;\n      kpis.fdvUsd = first.fdv;\n      kpis.mcUsd = first.marketCap;\n      kpis.priceChange24hPct = first.priceChange?.h24;\n      if (first.pairCreatedAt) {\n        const diff = Date.now() - Number(first.pairCreatedAt);\n        const days = Math.floor(diff / 86400000);\n        const hours = Math.floor((diff % 86400000) / 3600000);\n        kpis.age = { days, hours };\n      }\n    }\n\n    if (CG_API_BASE && CG_API_KEY) {\n      attempted.push('cg');\n      try {\n        const cg = await fetchCgToken(chain, address);\n        const attr = cg?.data?.attributes || cg?.data || cg;\n        const priceChange = attr?.price_change_percentage || {};\n        if (kpis.priceUsd === undefined && attr?.price_usd !== undefined)\n          kpis.priceUsd = Number(attr.price_usd);\n        if (kpis.mcUsd === undefined && attr?.market_cap_usd !== undefined)\n          kpis.mcUsd = Number(attr.market_cap_usd);\n        if (kpis.fdvUsd === undefined && attr?.fully_diluted_valuation_usd !== undefined)\n          kpis.fdvUsd = Number(attr.fully_diluted_valuation_usd);\n        if (kpis.priceChange24hPct === undefined && priceChange?.h24 !== undefined)\n          kpis.priceChange24hPct = Number(priceChange.h24);\n        if (!provider) provider = 'cg';\n        log('cg token');\n      } catch (err) {\n        logError('cg token fetch failed', err);\n      }\n    }\n\n    if (pools.length) {\n      headers['x-provider'] = provider || 'none';\n      headers['x-fallbacks-tried'] = attempted.join(',');\n      headers['x-items'] = String(pools.length);\n      const bodyRes: TokenResponse = {\n        info,\n        kpis,\n        pools,\n        provider: provider || 'cg',\n      };\n      log('response', event.rawUrl, 200, pools.length, provider || 'none');\n      return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n    }\n\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    headers['x-items'] = '0';\n    const bodyRes: TokenResponse & { note: string } = {\n      info: info || {},\n      kpis: {},\n      pools: [],\n      provider: 'none',\n      note: 'no_upstream_data',\n    };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n  } catch (err) {\n    logError('handler error', err);\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    const body: ApiError = { error: 'internal_error', provider: 'none' };\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n};\n"
        }
    ]
}