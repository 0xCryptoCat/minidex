{
    "sourceFile": "netlify/functions/trades.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1755456083101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755518756809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,8 +23,40 @@\n function isValidPair(id?: string): id is string {\n   return !!id;\n }\n \n+function isValidPoolAddress(addr?: string, chain?: string): boolean {\n+  if (!addr) return false;\n+  \n+  // EVM chains: 0x followed by 40 hex characters\n+  if (chain && ['ethereum', 'bsc', 'polygon', 'arbitrum', 'optimism', 'avalanche', 'base', 'fantom', 'linea', 'scroll', 'zksync', 'mantle', 'moonbeam', 'moonriver', 'cronos', 'harmony', 'celo', 'aurora', 'metis', 'boba', 'kava', 'gnosis'].includes(chain)) {\n+    return /^0x[a-fA-F0-9]{40}$/.test(addr);\n+  }\n+  \n+  // Solana: base58 encoded, typically 32-44 chars\n+  if (chain === 'solana') {\n+    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);\n+  }\n+  \n+  // TON: EQxxxx or UQxxxx format\n+  if (chain === 'ton') {\n+    return /^(EQ|UQ)[A-Za-z0-9_-]{46}$/.test(addr);\n+  }\n+  \n+  // SUI: 0x followed by 64 hex characters\n+  if (chain === 'sui') {\n+    return /^0x[a-fA-F0-9]{64}$/.test(addr);\n+  }\n+  \n+  // For other chains, be more permissive\n+  return addr.length >= 10 && addr.length <= 100;\n+}\n+\n+function isValidTokenAddress(addr?: string, chain?: string): boolean {\n+  if (!addr) return false;\n+  return isValidPoolAddress(addr, chain); // Same logic for now\n+}\n+\n async function readFixture(path: string): Promise<TradesResponse> {\n   const url = new URL(path, import.meta.url);\n   const data = await fs.readFile(url, 'utf8');\n   return JSON.parse(data) as TradesResponse;\n@@ -39,10 +71,10 @@\n   const windowH = Number(event.queryStringParameters?.window) || 24;\n   const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n   const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n   const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n-  const validPool = /^0x[0-9a-fA-F]{40}$/.test(poolAddress || '');\n-  const tokenOfInterest = tokenParam && /^0x[0-9a-fA-F]{40}$/.test(tokenParam)\n+  const validPool = isValidPoolAddress(poolAddress, chain);\n+  const tokenOfInterest = tokenParam && isValidTokenAddress(tokenParam, chain)\n     ? tokenParam.toLowerCase()\n     : undefined;\n \n   const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n"
                },
                {
                    "date": 1756118378416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,8 +182,9 @@\n               side,\n               price,\n               amountBase,\n               amountQuote,\n+              volumeUSD: volume_in_usd ?? 0), // Map volume_in_usd from GT API\n               txHash: attrs.tx_hash,\n               wallet: attrs.tx_from_address,\n             } as Trade;\n           });\n"
                },
                {
                    "date": 1756118412554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,17 @@\n import type { Handler } from '@netlify/functions';\n import type { TradesResponse, ApiError, Provider, Trade } from '../../src/lib/types';\n import fs from 'fs/promises';\n-import { CHAIN_TO_GT_NETWORK } from '../shared/chains';\n+import { CHA            return {\n+              ts,\n+              side,\n+              price,\n+              amountBase,\n+              amountQuote,\n+              volumeUSD: Number(attrs.volume_in_usd ?? 0), // Map volume_in_usd from GT API\n+              txHash: attrs.tx_hash,\n+              wallet: attrs.tx_from_address,\n+            } as Trade;ETWORK } from '../shared/chains';\n import { sanitizeTrades } from '../shared/agg';\n \n const GT_FIXTURE = '../../fixtures/trades-gt.json';\n \n@@ -150,8 +159,9 @@\n             const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n             const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n             const toAddr = String(attrs.to_token_address || '').toLowerCase();\n             const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n+            \n             let price = 0;\n             let amountBase = 0;\n             let amountQuote = 0;\n             let src: 'from' | 'to' = 'to';\n@@ -182,9 +192,9 @@\n               side,\n               price,\n               amountBase,\n               amountQuote,\n-              volumeUSD: volume_in_usd ?? 0), // Map volume_in_usd from GT API\n+              volumeUSD, // Map volume_in_usd from GT API\n               txHash: attrs.tx_hash,\n               wallet: attrs.tx_from_address,\n             } as Trade;\n           });\n@@ -307,8 +317,9 @@\n               side: String(sideRaw).toLowerCase() === 'sell' ? 'sell' : 'buy',\n               price,\n               amountBase,\n               amountQuote,\n+              volumeUSD: Number(attrs.volume_in_usd ?? attrs.volumeUSD ?? attrs.volume_usd ?? 0), // Map volume from CG API\n               txHash: attrs.tx_hash || attrs.txHash,\n               wallet: attrs.tx_from_address || attrs.wallet || attrs.address,\n             } as Trade;\n           });\n"
                },
                {
                    "date": 1756118412748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,17 +1,8 @@\n import type { Handler } from '@netlify/functions';\n import type { TradesResponse, ApiError, Provider, Trade } from '../../src/lib/types';\n import fs from 'fs/promises';\n-import { CHA            return {\n-              ts,\n-              side,\n-              price,\n-              amountBase,\n-              amountQuote,\n-              volumeUSD: Number(attrs.volume_in_usd ?? 0), // Map volume_in_usd from GT API\n-              txHash: attrs.tx_hash,\n-              wallet: attrs.tx_from_address,\n-            } as Trade;ETWORK } from '../shared/chains';\n+import { CHAIN_TO_GT_NETWORK } from '../shared/chains';\n import { sanitizeTrades } from '../shared/agg';\n \n const GT_FIXTURE = '../../fixtures/trades-gt.json';\n \n"
                },
                {
                    "date": 1756118436721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,346 @@\n+import type { Handler } from '@netlify/functions';\n+import type { TradesResponse, ApiError, Provider, Trade } from '../../src/lib/types';\n+import fs from 'fs/promises';\n+import { CHAIN_TO_GT_NETWORK } from '../shared/chains';\n+import { sanitizeTrades } from '../shared/agg';\n+\n+const GT_FIXTURE = '../../fixtures/trades-gt.json';\n+\n+const USE_FIXTURES = process.env.USE_FIXTURES === 'true';\n+const GT_API_BASE = process.env.GT_API_BASE || 'https://api.geckoterminal.com/api/v2';\n+const CG_API_BASE = process.env.COINGECKO_API_BASE || '';\n+const CG_API_KEY = process.env.COINGECKO_API_KEY || '';\n+const DEBUG = process.env.DEBUG_LOGS === 'true';\n+\n+function log(...args: any[]) {\n+  if (DEBUG) console.log('[trades]', ...args);\n+}\n+\n+function logError(...args: any[]) {\n+  console.error('[trades]', ...args);\n+}\n+\n+function isValidPair(id?: string): id is string {\n+  return !!id;\n+}\n+\n+function isValidPoolAddress(addr?: string, chain?: string): boolean {\n+  if (!addr) return false;\n+  \n+  // EVM chains: 0x followed by 40 hex characters\n+  if (chain && ['ethereum', 'bsc', 'polygon', 'arbitrum', 'optimism', 'avalanche', 'base', 'fantom', 'linea', 'scroll', 'zksync', 'mantle', 'moonbeam', 'moonriver', 'cronos', 'harmony', 'celo', 'aurora', 'metis', 'boba', 'kava', 'gnosis'].includes(chain)) {\n+    return /^0x[a-fA-F0-9]{40}$/.test(addr);\n+  }\n+  \n+  // Solana: base58 encoded, typically 32-44 chars\n+  if (chain === 'solana') {\n+    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);\n+  }\n+  \n+  // TON: EQxxxx or UQxxxx format\n+  if (chain === 'ton') {\n+    return /^(EQ|UQ)[A-Za-z0-9_-]{46}$/.test(addr);\n+  }\n+  \n+  // SUI: 0x followed by 64 hex characters\n+  if (chain === 'sui') {\n+    return /^0x[a-fA-F0-9]{64}$/.test(addr);\n+  }\n+  \n+  // For other chains, be more permissive\n+  return addr.length >= 10 && addr.length <= 100;\n+}\n+\n+function isValidTokenAddress(addr?: string, chain?: string): boolean {\n+  if (!addr) return false;\n+  return isValidPoolAddress(addr, chain); // Same logic for now\n+}\n+\n+async function readFixture(path: string): Promise<TradesResponse> {\n+  const url = new URL(path, import.meta.url);\n+  const data = await fs.readFile(url, 'utf8');\n+  return JSON.parse(data) as TradesResponse;\n+}\n+\n+export const handler: Handler = async (event) => {\n+  const pairId = event.queryStringParameters?.pairId;\n+  const chain = event.queryStringParameters?.chain;\n+  const poolAddress = event.queryStringParameters?.poolAddress;\n+  const tokenParam = event.queryStringParameters?.token;\n+  const limit = Number(event.queryStringParameters?.limit) || 200;\n+  const windowH = Number(event.queryStringParameters?.window) || 24;\n+  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n+  const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n+  const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n+  const validPool = isValidPoolAddress(poolAddress, chain);\n+  const tokenOfInterest = tokenParam && isValidTokenAddress(tokenParam, chain)\n+    ? tokenParam.toLowerCase()\n+    : undefined;\n+\n+  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n+\n+  const headers: Record<string, string> = {\n+    'Content-Type': 'application/json',\n+    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n+    'x-provider': 'none',\n+    'x-fallbacks-tried': '',\n+    'x-items': '0',\n+  };\n+  const attempted: string[] = [];\n+  if (!CG_API_KEY) attempted.push('cg:disabled');\n+  if (!isValidPair(pairId) || !chain) {\n+    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n+    log('response', event.rawUrl, 400, 0, 'none');\n+    return { statusCode: 400, headers, body: JSON.stringify(body) };\n+  }\n+  if (!SUPPORTED_CHAINS.includes(chain)) {\n+    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n+    log('response', event.rawUrl, 200, 0, 'none');\n+    return { statusCode: 200, headers, body: JSON.stringify(body) };\n+  }\n+\n+  log('params', { pairId, chain, poolAddress, tokenOfInterest, forceProvider, limit, windowH, gtSupported, gtNetwork });\n+  try {\n+    if (!gtNetwork) {\n+      log('skip gt: invalid network', chain);\n+    }\n+    if (!validPool) {\n+      headers['x-invalid-pool'] = '1';\n+      log('skip gt: invalid pool', poolAddress);\n+    }\n+\n+    if (USE_FIXTURES) {\n+      try {\n+        attempted.push('gt');\n+        const gt = await readFixture(GT_FIXTURE);\n+        gt.pairId = pairId;\n+        headers['x-provider'] = 'gt';\n+        headers['x-fallbacks-tried'] = attempted.join(',');\n+        headers['x-items'] = String(gt.trades.length);\n+        log('response', event.rawUrl, 200, gt.trades.length, 'gt');\n+        return { statusCode: 200, headers, body: JSON.stringify(gt) };\n+      } catch (err) {\n+        logError('fixture read failed', err);\n+        headers['x-fallbacks-tried'] = attempted.join(',');\n+        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n+        log('response', event.rawUrl, 500, 0, 'none');\n+        return { statusCode: 500, headers, body: JSON.stringify(body) };\n+      }\n+    }\n+\n+    let trades: Trade[] = [];\n+    let provider: Provider | 'none' = 'none';\n+    let priceSourceHeader: 'from' | 'to' | '' = '';\n+    const cutoff = Date.now() - windowH * 3600 * 1000;\n+\n+    if (\n+      (forceProvider === 'gt' || (!forceProvider && gtSupported)) &&\n+      gtNetwork &&\n+      validPool\n+    ) {\n+      attempted.push('gt');\n+      try {\n+        const gtUrl = `${GT_API_BASE}/networks/${gtNetwork}/pools/${poolAddress}/trades?limit=${limit}`;\n+        const gtResp = await fetch(gtUrl);\n+        if (gtResp.ok) {\n+          const gtData = await gtResp.json();\n+          const list = Array.isArray(gtData.data) ? gtData.data : [];\n+          const tradesGt = list.map((t: any) => {\n+            const attrs = t.attributes || {};\n+            const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n+            const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n+            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n+            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n+            const volumeUSD = Number(attrs.volume_in_usd ?? 0); // Map volume_in_usd from GT API\n+            let price = 0;\n+            let amountBase = 0;\n+            let amountQuote = 0;\n+            let src: 'from' | 'to' = 'to';\n+            if (tokenOfInterest && tokenOfInterest === toAddr) {\n+              price = Number(attrs.price_to_in_usd ?? 0);\n+              amountBase = Number(attrs.to_token_amount ?? 0);\n+              amountQuote = Number(attrs.from_token_amount ?? 0);\n+              src = 'to';\n+            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n+              price = Number(attrs.price_from_in_usd ?? 0);\n+              amountBase = Number(attrs.from_token_amount ?? 0);\n+              amountQuote = Number(attrs.to_token_amount ?? 0);\n+              src = 'from';\n+            } else if (attrs.price_to_in_usd !== undefined) {\n+              price = Number(attrs.price_to_in_usd ?? 0);\n+              amountBase = Number(attrs.to_token_amount ?? 0);\n+              amountQuote = Number(attrs.from_token_amount ?? 0);\n+              src = 'to';\n+            } else {\n+              price = Number(attrs.price_from_in_usd ?? 0);\n+              amountBase = Number(attrs.from_token_amount ?? 0);\n+              amountQuote = Number(attrs.to_token_amount ?? 0);\n+              src = 'from';\n+            }\n+            if (!priceSourceHeader) priceSourceHeader = src;\n+            return {\n+              ts,\n+              side,\n+              price,\n+              amountBase,\n+              amountQuote,\n+              volumeUSD, // Map volume_in_usd from GT API\n+              txHash: attrs.tx_hash,\n+              wallet: attrs.tx_from_address,\n+            } as Trade;\n+          });\n+          trades = sanitizeTrades(\n+            tradesGt.filter((t) => t.ts * 1000 >= cutoff).slice(0, limit)\n+          );\n+          if (trades.length > 0) {\n+            provider = 'gt';\n+            log('gt trades', trades.length);\n+          }\n+        }\n+      } catch (err) {\n+        logError('gt trades fetch failed', err);\n+        // ignore\n+      }\n+    }\n+\n+    if (trades.length === 0 && (forceProvider !== 'gt') && CG_API_BASE && CG_API_KEY && chain && poolAddress) {\n+      attempted.push('cg');\n+      try {\n+        const cgUrl = `${CG_API_BASE}/pool-trades-contract-address?chain=${chain}&address=${poolAddress}&limit=300`;\n+        const res = await fetch(cgUrl, {\n+          headers: { 'x-cg-pro-api-key': CG_API_KEY },\n+        });\n+        if (res.status === 401 || res.status === 403) {\n+          headers['x-cg-auth'] = 'fail';\n+          log('cg auth fail', res.status);\n+        }\n+        if (res.ok) {\n+          const cg = await res.json();\n+          const list = Array.isArray(cg?.data)\n+            ? cg.data\n+            : Array.isArray(cg?.trades)\n+            ? cg.trades\n+            : Array.isArray(cg)\n+            ? cg\n+            : [];\n+          const tradesCg = list.map((t: any) => {\n+            const attrs = t.attributes || t;\n+            const tsRaw = attrs.timestamp ?? attrs.ts ?? attrs.time ?? attrs[0];\n+            let ts = Number(tsRaw);\n+            if (!Number.isFinite(ts)) {\n+              ts = Math.floor(Date.parse(String(tsRaw)) / 1000);\n+            }\n+            const sideRaw = attrs.kind ?? attrs.trade_type ?? attrs.side ?? attrs.type ?? '';\n+            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n+            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n+            let price = 0;\n+            let amountBase = 0;\n+            let amountQuote = 0;\n+            let src: 'from' | 'to' = 'to';\n+            if (tokenOfInterest && tokenOfInterest === toAddr) {\n+              price = Number(\n+                attrs.price_to_in_usd ??\n+                  attrs.price_usd ??\n+                  attrs.priceUsd ??\n+                  attrs.price ??\n+                  attrs[1] ??\n+                  0\n+              );\n+              amountBase = Number(\n+                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              );\n+              amountQuote = Number(\n+                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              );\n+              src = 'to';\n+            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n+              price = Number(\n+                attrs.price_from_in_usd ??\n+                  attrs.price_usd ??\n+                  attrs.priceUsd ??\n+                  attrs.price ??\n+                  attrs[1] ??\n+                  0\n+              );\n+              amountBase = Number(\n+                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              );\n+              amountQuote = Number(\n+                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              );\n+              src = 'from';\n+            } else if (attrs.price_to_in_usd !== undefined) {\n+              price = Number(\n+                attrs.price_to_in_usd ??\n+                  attrs.price_usd ??\n+                  attrs.priceUsd ??\n+                  attrs.price ??\n+                  attrs[1] ??\n+                  0\n+              );\n+              amountBase = Number(\n+                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              );\n+              amountQuote = Number(\n+                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              );\n+              src = 'to';\n+            } else {\n+              price = Number(\n+                attrs.price_from_in_usd ??\n+                  attrs.price_usd ??\n+                  attrs.priceUsd ??\n+                  attrs.price ??\n+                  attrs[1] ??\n+                  0\n+              );\n+              amountBase = Number(\n+                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              );\n+              amountQuote = Number(\n+                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              );\n+              src = 'from';\n+            }\n+            if (!priceSourceHeader) priceSourceHeader = src;\n+            return {\n+              ts,\n+              side: String(sideRaw).toLowerCase() === 'sell' ? 'sell' : 'buy',\n+              price,\n+              amountBase,\n+              amountQuote,\n+              volumeUSD: Number(attrs.volume_in_usd ?? attrs.volumeUSD ?? attrs.volume_usd ?? 0), // Map volume from CG API\n+              txHash: attrs.tx_hash || attrs.txHash,\n+              wallet: attrs.tx_from_address || attrs.wallet || attrs.address,\n+            } as Trade;\n+          });\n+          trades = sanitizeTrades(\n+            tradesCg.filter((t: Trade) => t.ts * 1000 >= cutoff).slice(0, limit)\n+          );\n+          if (trades.length > 0) {\n+            provider = 'cg';\n+            log('cg trades', trades.length);\n+          }\n+        }\n+      } catch (err) {\n+        logError('cg trades fetch failed', err);\n+        // ignore and fall through\n+      }\n+    }\n+\n+    const bodyRes: TradesResponse = { pairId, trades, provider: provider as Provider };\n+    headers['x-provider'] = provider;\n+    headers['x-fallbacks-tried'] = attempted.join(',');\n+    headers['x-items'] = String(trades.length);\n+    if (tokenOfInterest) headers['x-token'] = tokenOfInterest;\n+    if (priceSourceHeader) headers['x-price-source'] = priceSourceHeader;\n+    log('response', event.rawUrl, 200, trades.length, provider);\n+    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n+  } catch (err) {\n+    logError('handler error', err);\n+    headers['x-fallbacks-tried'] = attempted.join(',');\n+    const body: ApiError = { error: 'internal_error', provider: 'none' };\n+    return { statusCode: 500, headers, body: JSON.stringify(body) };\n+  }\n+};\n+\n"
                },
                {
                    "date": 1756118507501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -343,350 +343,4 @@\n     return { statusCode: 500, headers, body: JSON.stringify(body) };\n   }\n };\n \n-import type { Handler } from '@netlify/functions';\n-import type { TradesResponse, ApiError, Provider, Trade } from '../../src/lib/types';\n-import fs from 'fs/promises';\n-import { CHAIN_TO_GT_NETWORK } from '../shared/chains';\n-import { sanitizeTrades } from '../shared/agg';\n-\n-const GT_FIXTURE = '../../fixtures/trades-gt.json';\n-\n-const USE_FIXTURES = process.env.USE_FIXTURES === 'true';\n-const GT_API_BASE = process.env.GT_API_BASE || 'https://api.geckoterminal.com/api/v2';\n-const CG_API_BASE = process.env.COINGECKO_API_BASE || '';\n-const CG_API_KEY = process.env.COINGECKO_API_KEY || '';\n-const DEBUG = process.env.DEBUG_LOGS === 'true';\n-\n-function log(...args: any[]) {\n-  if (DEBUG) console.log('[trades]', ...args);\n-}\n-\n-function logError(...args: any[]) {\n-  console.error('[trades]', ...args);\n-}\n-\n-function isValidPair(id?: string): id is string {\n-  return !!id;\n-}\n-\n-function isValidPoolAddress(addr?: string, chain?: string): boolean {\n-  if (!addr) return false;\n-  \n-  // EVM chains: 0x followed by 40 hex characters\n-  if (chain && ['ethereum', 'bsc', 'polygon', 'arbitrum', 'optimism', 'avalanche', 'base', 'fantom', 'linea', 'scroll', 'zksync', 'mantle', 'moonbeam', 'moonriver', 'cronos', 'harmony', 'celo', 'aurora', 'metis', 'boba', 'kava', 'gnosis'].includes(chain)) {\n-    return /^0x[a-fA-F0-9]{40}$/.test(addr);\n-  }\n-  \n-  // Solana: base58 encoded, typically 32-44 chars\n-  if (chain === 'solana') {\n-    return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);\n-  }\n-  \n-  // TON: EQxxxx or UQxxxx format\n-  if (chain === 'ton') {\n-    return /^(EQ|UQ)[A-Za-z0-9_-]{46}$/.test(addr);\n-  }\n-  \n-  // SUI: 0x followed by 64 hex characters\n-  if (chain === 'sui') {\n-    return /^0x[a-fA-F0-9]{64}$/.test(addr);\n-  }\n-  \n-  // For other chains, be more permissive\n-  return addr.length >= 10 && addr.length <= 100;\n-}\n-\n-function isValidTokenAddress(addr?: string, chain?: string): boolean {\n-  if (!addr) return false;\n-  return isValidPoolAddress(addr, chain); // Same logic for now\n-}\n-\n-async function readFixture(path: string): Promise<TradesResponse> {\n-  const url = new URL(path, import.meta.url);\n-  const data = await fs.readFile(url, 'utf8');\n-  return JSON.parse(data) as TradesResponse;\n-}\n-\n-export const handler: Handler = async (event) => {\n-  const pairId = event.queryStringParameters?.pairId;\n-  const chain = event.queryStringParameters?.chain;\n-  const poolAddress = event.queryStringParameters?.poolAddress;\n-  const tokenParam = event.queryStringParameters?.token;\n-  const limit = Number(event.queryStringParameters?.limit) || 200;\n-  const windowH = Number(event.queryStringParameters?.window) || 24;\n-  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n-  const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n-  const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n-  const validPool = isValidPoolAddress(poolAddress, chain);\n-  const tokenOfInterest = tokenParam && isValidTokenAddress(tokenParam, chain)\n-    ? tokenParam.toLowerCase()\n-    : undefined;\n-\n-  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n-\n-  const headers: Record<string, string> = {\n-    'Content-Type': 'application/json',\n-    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n-    'x-provider': 'none',\n-    'x-fallbacks-tried': '',\n-    'x-items': '0',\n-  };\n-  const attempted: string[] = [];\n-  if (!CG_API_KEY) attempted.push('cg:disabled');\n-  if (!isValidPair(pairId) || !chain) {\n-    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n-    log('response', event.rawUrl, 400, 0, 'none');\n-    return { statusCode: 400, headers, body: JSON.stringify(body) };\n-  }\n-  if (!SUPPORTED_CHAINS.includes(chain)) {\n-    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n-    log('response', event.rawUrl, 200, 0, 'none');\n-    return { statusCode: 200, headers, body: JSON.stringify(body) };\n-  }\n-\n-  log('params', { pairId, chain, poolAddress, tokenOfInterest, forceProvider, limit, windowH, gtSupported, gtNetwork });\n-  try {\n-    if (!gtNetwork) {\n-      log('skip gt: invalid network', chain);\n-    }\n-    if (!validPool) {\n-      headers['x-invalid-pool'] = '1';\n-      log('skip gt: invalid pool', poolAddress);\n-    }\n-\n-    if (USE_FIXTURES) {\n-      try {\n-        attempted.push('gt');\n-        const gt = await readFixture(GT_FIXTURE);\n-        gt.pairId = pairId;\n-        headers['x-provider'] = 'gt';\n-        headers['x-fallbacks-tried'] = attempted.join(',');\n-        headers['x-items'] = String(gt.trades.length);\n-        log('response', event.rawUrl, 200, gt.trades.length, 'gt');\n-        return { statusCode: 200, headers, body: JSON.stringify(gt) };\n-      } catch (err) {\n-        logError('fixture read failed', err);\n-        headers['x-fallbacks-tried'] = attempted.join(',');\n-        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n-        log('response', event.rawUrl, 500, 0, 'none');\n-        return { statusCode: 500, headers, body: JSON.stringify(body) };\n-      }\n-    }\n-\n-    let trades: Trade[] = [];\n-    let provider: Provider | 'none' = 'none';\n-    let priceSourceHeader: 'from' | 'to' | '' = '';\n-    const cutoff = Date.now() - windowH * 3600 * 1000;\n-\n-    if (\n-      (forceProvider === 'gt' || (!forceProvider && gtSupported)) &&\n-      gtNetwork &&\n-      validPool\n-    ) {\n-      attempted.push('gt');\n-      try {\n-        const gtUrl = `${GT_API_BASE}/networks/${gtNetwork}/pools/${poolAddress}/trades?limit=${limit}`;\n-        const gtResp = await fetch(gtUrl);\n-        if (gtResp.ok) {\n-          const gtData = await gtResp.json();\n-          const list = Array.isArray(gtData.data) ? gtData.data : [];\n-          const tradesGt = list.map((t: any) => {\n-            const attrs = t.attributes || {};\n-            const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n-            const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n-            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n-            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n-            \n-            let price = 0;\n-            let amountBase = 0;\n-            let amountQuote = 0;\n-            let src: 'from' | 'to' = 'to';\n-            if (tokenOfInterest && tokenOfInterest === toAddr) {\n-              price = Number(attrs.price_to_in_usd ?? 0);\n-              amountBase = Number(attrs.to_token_amount ?? 0);\n-              amountQuote = Number(attrs.from_token_amount ?? 0);\n-              src = 'to';\n-            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n-              price = Number(attrs.price_from_in_usd ?? 0);\n-              amountBase = Number(attrs.from_token_amount ?? 0);\n-              amountQuote = Number(attrs.to_token_amount ?? 0);\n-              src = 'from';\n-            } else if (attrs.price_to_in_usd !== undefined) {\n-              price = Number(attrs.price_to_in_usd ?? 0);\n-              amountBase = Number(attrs.to_token_amount ?? 0);\n-              amountQuote = Number(attrs.from_token_amount ?? 0);\n-              src = 'to';\n-            } else {\n-              price = Number(attrs.price_from_in_usd ?? 0);\n-              amountBase = Number(attrs.from_token_amount ?? 0);\n-              amountQuote = Number(attrs.to_token_amount ?? 0);\n-              src = 'from';\n-            }\n-            if (!priceSourceHeader) priceSourceHeader = src;\n-            return {\n-              ts,\n-              side,\n-              price,\n-              amountBase,\n-              amountQuote,\n-              volumeUSD, // Map volume_in_usd from GT API\n-              txHash: attrs.tx_hash,\n-              wallet: attrs.tx_from_address,\n-            } as Trade;\n-          });\n-          trades = sanitizeTrades(\n-            tradesGt.filter((t) => t.ts * 1000 >= cutoff).slice(0, limit)\n-          );\n-          if (trades.length > 0) {\n-            provider = 'gt';\n-            log('gt trades', trades.length);\n-          }\n-        }\n-      } catch (err) {\n-        logError('gt trades fetch failed', err);\n-        // ignore\n-      }\n-    }\n-\n-    if (trades.length === 0 && (forceProvider !== 'gt') && CG_API_BASE && CG_API_KEY && chain && poolAddress) {\n-      attempted.push('cg');\n-      try {\n-        const cgUrl = `${CG_API_BASE}/pool-trades-contract-address?chain=${chain}&address=${poolAddress}&limit=300`;\n-        const res = await fetch(cgUrl, {\n-          headers: { 'x-cg-pro-api-key': CG_API_KEY },\n-        });\n-        if (res.status === 401 || res.status === 403) {\n-          headers['x-cg-auth'] = 'fail';\n-          log('cg auth fail', res.status);\n-        }\n-        if (res.ok) {\n-          const cg = await res.json();\n-          const list = Array.isArray(cg?.data)\n-            ? cg.data\n-            : Array.isArray(cg?.trades)\n-            ? cg.trades\n-            : Array.isArray(cg)\n-            ? cg\n-            : [];\n-          const tradesCg = list.map((t: any) => {\n-            const attrs = t.attributes || t;\n-            const tsRaw = attrs.timestamp ?? attrs.ts ?? attrs.time ?? attrs[0];\n-            let ts = Number(tsRaw);\n-            if (!Number.isFinite(ts)) {\n-              ts = Math.floor(Date.parse(String(tsRaw)) / 1000);\n-            }\n-            const sideRaw = attrs.kind ?? attrs.trade_type ?? attrs.side ?? attrs.type ?? '';\n-            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n-            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n-            let price = 0;\n-            let amountBase = 0;\n-            let amountQuote = 0;\n-            let src: 'from' | 'to' = 'to';\n-            if (tokenOfInterest && tokenOfInterest === toAddr) {\n-              price = Number(\n-                attrs.price_to_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n-              );\n-              amountBase = Number(\n-                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n-              );\n-              amountQuote = Number(\n-                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n-              );\n-              src = 'to';\n-            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n-              price = Number(\n-                attrs.price_from_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n-              );\n-              amountBase = Number(\n-                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n-              );\n-              amountQuote = Number(\n-                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n-              );\n-              src = 'from';\n-            } else if (attrs.price_to_in_usd !== undefined) {\n-              price = Number(\n-                attrs.price_to_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n-              );\n-              amountBase = Number(\n-                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n-              );\n-              amountQuote = Number(\n-                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n-              );\n-              src = 'to';\n-            } else {\n-              price = Number(\n-                attrs.price_from_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n-              );\n-              amountBase = Number(\n-                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n-              );\n-              amountQuote = Number(\n-                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n-              );\n-              src = 'from';\n-            }\n-            if (!priceSourceHeader) priceSourceHeader = src;\n-            return {\n-              ts,\n-              side: String(sideRaw).toLowerCase() === 'sell' ? 'sell' : 'buy',\n-              price,\n-              amountBase,\n-              amountQuote,\n-              volumeUSD: Number(attrs.volume_in_usd ?? attrs.volumeUSD ?? attrs.volume_usd ?? 0), // Map volume from CG API\n-              txHash: attrs.tx_hash || attrs.txHash,\n-              wallet: attrs.tx_from_address || attrs.wallet || attrs.address,\n-            } as Trade;\n-          });\n-          trades = sanitizeTrades(\n-            tradesCg.filter((t: Trade) => t.ts * 1000 >= cutoff).slice(0, limit)\n-          );\n-          if (trades.length > 0) {\n-            provider = 'cg';\n-            log('cg trades', trades.length);\n-          }\n-        }\n-      } catch (err) {\n-        logError('cg trades fetch failed', err);\n-        // ignore and fall through\n-      }\n-    }\n-\n-    const bodyRes: TradesResponse = { pairId, trades, provider: provider as Provider };\n-    headers['x-provider'] = provider;\n-    headers['x-fallbacks-tried'] = attempted.join(',');\n-    headers['x-items'] = String(trades.length);\n-    if (tokenOfInterest) headers['x-token'] = tokenOfInterest;\n-    if (priceSourceHeader) headers['x-price-source'] = priceSourceHeader;\n-    log('response', event.rawUrl, 200, trades.length, provider);\n-    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n-  } catch (err) {\n-    logError('handler error', err);\n-    headers['x-fallbacks-tried'] = attempted.join(',');\n-    const body: ApiError = { error: 'internal_error', provider: 'none' };\n-    return { statusCode: 500, headers, body: JSON.stringify(body) };\n-  }\n-};\n-\n"
                },
                {
                    "date": 1756118813075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,9 +183,9 @@\n               side,\n               price,\n               amountBase,\n               amountQuote,\n-              volumeUSD, // Map volume_in_usd from GT API\n+              volumeUSD: Number(attrs.volume_in_usd ?? 0), // Map volume_in_usd from GT API\n               txHash: attrs.tx_hash,\n               wallet: attrs.tx_from_address,\n             } as Trade;\n           });\n"
                },
                {
                    "date": 1756119230413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,13 +146,16 @@\n           const gtData = await gtResp.json();\n           const list = Array.isArray(gtData.data) ? gtData.data : [];\n           const tradesGt = list.map((t: any) => {\n             const attrs = t.attributes || {};\n+            // Debug: Log raw volume_in_usd value\n+            if (DEBUG && attrs.volume_in_usd) {\n+              log('raw volume_in_usd:', attrs.volume_in_usd, typeof attrs.volume_in_usd);\n+            }\n             const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n             const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n             const toAddr = String(attrs.to_token_address || '').toLowerCase();\n             const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n-            const volumeUSD = Number(attrs.volume_in_usd ?? 0); // Map volume_in_usd from GT API\n             let price = 0;\n             let amountBase = 0;\n             let amountQuote = 0;\n             let src: 'from' | 'to' = 'to';\n@@ -177,15 +180,20 @@\n               amountQuote = Number(attrs.to_token_amount ?? 0);\n               src = 'from';\n             }\n             if (!priceSourceHeader) priceSourceHeader = src;\n+            const parsedVolumeUSD = parseFloat(attrs.volume_in_usd || '0');\n+            // Debug: Log parsed volume\n+            if (DEBUG && attrs.volume_in_usd) {\n+              log('parsed volumeUSD:', parsedVolumeUSD, 'from raw:', attrs.volume_in_usd);\n+            }\n             return {\n               ts,\n               side,\n               price,\n               amountBase,\n               amountQuote,\n-              volumeUSD: Number(attrs.volume_in_usd ?? 0), // Map volume_in_usd from GT API\n+              volumeUSD: parsedVolumeUSD, // Parse volume_in_usd string from GT API\n               txHash: attrs.tx_hash,\n               wallet: attrs.tx_from_address,\n             } as Trade;\n           });\n@@ -194,8 +202,16 @@\n           );\n           if (trades.length > 0) {\n             provider = 'gt';\n             log('gt trades', trades.length);\n+            // Debug: Log sample volume data\n+            if (DEBUG && trades.length > 0) {\n+              log('sample volumes:', trades.slice(0, 2).map(t => ({ \n+                volumeUSD: t.volumeUSD, \n+                price: t.price, \n+                amountBase: t.amountBase \n+              })));\n+            }\n           }\n         }\n       } catch (err) {\n         logError('gt trades fetch failed', err);\n@@ -308,9 +324,9 @@\n               side: String(sideRaw).toLowerCase() === 'sell' ? 'sell' : 'buy',\n               price,\n               amountBase,\n               amountQuote,\n-              volumeUSD: Number(attrs.volume_in_usd ?? attrs.volumeUSD ?? attrs.volume_usd ?? 0), // Map volume from CG API\n+              volumeUSD: parseFloat(attrs.volume_in_usd || attrs.volumeUSD || attrs.volume_usd || '0'), // Parse volume strings from CG API\n               txHash: attrs.tx_hash || attrs.txHash,\n               wallet: attrs.tx_from_address || attrs.wallet || attrs.address,\n             } as Trade;\n           });\n"
                },
                {
                    "date": 1756119729757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,34 +151,34 @@\n             if (DEBUG && attrs.volume_in_usd) {\n               log('raw volume_in_usd:', attrs.volume_in_usd, typeof attrs.volume_in_usd);\n             }\n             const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n-            const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n+            const side = String(attrs.kind || '').toLowerCase() === 'buy' ? 'buy' : 'sell';\n             const toAddr = String(attrs.to_token_address || '').toLowerCase();\n             const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n             let price = 0;\n             let amountBase = 0;\n             let amountQuote = 0;\n             let src: 'from' | 'to' = 'to';\n             if (tokenOfInterest && tokenOfInterest === toAddr) {\n-              price = Number(attrs.price_to_in_usd ?? 0);\n-              amountBase = Number(attrs.to_token_amount ?? 0);\n-              amountQuote = Number(attrs.from_token_amount ?? 0);\n+              price = parseFloat(attrs.price_to_in_usd || '0');\n+              amountBase = parseFloat(attrs.to_token_amount || '0');\n+              amountQuote = parseFloat(attrs.from_token_amount || '0');\n               src = 'to';\n             } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n-              price = Number(attrs.price_from_in_usd ?? 0);\n-              amountBase = Number(attrs.from_token_amount ?? 0);\n-              amountQuote = Number(attrs.to_token_amount ?? 0);\n+              price = parseFloat(attrs.price_from_in_usd || '0');\n+              amountBase = parseFloat(attrs.from_token_amount || '0');\n+              amountQuote = parseFloat(attrs.to_token_amount || '0');\n               src = 'from';\n-            } else if (attrs.price_to_in_usd !== undefined) {\n-              price = Number(attrs.price_to_in_usd ?? 0);\n-              amountBase = Number(attrs.to_token_amount ?? 0);\n-              amountQuote = Number(attrs.from_token_amount ?? 0);\n+            } else if (attrs.price_to_in_usd) {\n+              price = parseFloat(attrs.price_to_in_usd || '0');\n+              amountBase = parseFloat(attrs.to_token_amount || '0');\n+              amountQuote = parseFloat(attrs.from_token_amount || '0');\n               src = 'to';\n             } else {\n-              price = Number(attrs.price_from_in_usd ?? 0);\n-              amountBase = Number(attrs.from_token_amount ?? 0);\n-              amountQuote = Number(attrs.to_token_amount ?? 0);\n+              price = parseFloat(attrs.price_from_in_usd || '0');\n+              amountBase = parseFloat(attrs.from_token_amount || '0');\n+              amountQuote = parseFloat(attrs.to_token_amount || '0');\n               src = 'from';\n             }\n             if (!priceSourceHeader) priceSourceHeader = src;\n             const parsedVolumeUSD = parseFloat(attrs.volume_in_usd || '0');\n@@ -192,10 +192,10 @@\n               price,\n               amountBase,\n               amountQuote,\n               volumeUSD: parsedVolumeUSD, // Parse volume_in_usd string from GT API\n-              txHash: attrs.tx_hash,\n-              wallet: attrs.tx_from_address,\n+              txHash: attrs.tx_hash || '',\n+              wallet: attrs.tx_from_address || '',\n             } as Trade;\n           });\n           trades = sanitizeTrades(\n             tradesGt.filter((t) => t.ts * 1000 >= cutoff).slice(0, limit)\n@@ -253,69 +253,69 @@\n             let amountBase = 0;\n             let amountQuote = 0;\n             let src: 'from' | 'to' = 'to';\n             if (tokenOfInterest && tokenOfInterest === toAddr) {\n-              price = Number(\n-                attrs.price_to_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n+              price = parseFloat(\n+                attrs.price_to_in_usd ||\n+                  attrs.price_usd ||\n+                  attrs.priceUsd ||\n+                  attrs.price ||\n+                  attrs[1] ||\n+                  '0'\n               );\n-              amountBase = Number(\n-                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              amountBase = parseFloat(\n+                attrs.to_token_amount || attrs.amount_base || attrs.amount_base_token || '0'\n               );\n-              amountQuote = Number(\n-                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              amountQuote = parseFloat(\n+                attrs.from_token_amount || attrs.amount_quote || attrs.amount_quote_token || '0'\n               );\n               src = 'to';\n             } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n-              price = Number(\n-                attrs.price_from_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n+              price = parseFloat(\n+                attrs.price_from_in_usd ||\n+                  attrs.price_usd ||\n+                  attrs.priceUsd ||\n+                  attrs.price ||\n+                  attrs[1] ||\n+                  '0'\n               );\n-              amountBase = Number(\n-                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              amountBase = parseFloat(\n+                attrs.from_token_amount || attrs.amount_base || attrs.amount_base_token || '0'\n               );\n-              amountQuote = Number(\n-                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              amountQuote = parseFloat(\n+                attrs.to_token_amount || attrs.amount_quote || attrs.amount_quote_token || '0'\n               );\n               src = 'from';\n-            } else if (attrs.price_to_in_usd !== undefined) {\n-              price = Number(\n-                attrs.price_to_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n+            } else if (attrs.price_to_in_usd) {\n+              price = parseFloat(\n+                attrs.price_to_in_usd ||\n+                  attrs.price_usd ||\n+                  attrs.priceUsd ||\n+                  attrs.price ||\n+                  attrs[1] ||\n+                  '0'\n               );\n-              amountBase = Number(\n-                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              amountBase = parseFloat(\n+                attrs.to_token_amount || attrs.amount_base || attrs.amount_base_token || '0'\n               );\n-              amountQuote = Number(\n-                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              amountQuote = parseFloat(\n+                attrs.from_token_amount || attrs.amount_quote || attrs.amount_quote_token || '0'\n               );\n               src = 'to';\n             } else {\n-              price = Number(\n-                attrs.price_from_in_usd ??\n-                  attrs.price_usd ??\n-                  attrs.priceUsd ??\n-                  attrs.price ??\n-                  attrs[1] ??\n-                  0\n+              price = parseFloat(\n+                attrs.price_from_in_usd ||\n+                  attrs.price_usd ||\n+                  attrs.priceUsd ||\n+                  attrs.price ||\n+                  attrs[1] ||\n+                  '0'\n               );\n-              amountBase = Number(\n-                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n+              amountBase = parseFloat(\n+                attrs.from_token_amount || attrs.amount_base || attrs.amount_base_token || '0'\n               );\n-              amountQuote = Number(\n-                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n+              amountQuote = parseFloat(\n+                attrs.to_token_amount || attrs.amount_quote || attrs.amount_quote_token || '0'\n               );\n               src = 'from';\n             }\n             if (!priceSourceHeader) priceSourceHeader = src;\n"
                },
                {
                    "date": 1756120102960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,12 +55,12 @@\n   if (!addr) return false;\n   return isValidPoolAddress(addr, chain); // Same logic for now\n }\n \n-async function readFixture(path: string): Promise<TradesResponse> {\n+async function readFixture(path: string): Promise<any> {\n   const url = new URL(path, import.meta.url);\n   const data = await fs.readFile(url, 'utf8');\n-  return JSON.parse(data) as TradesResponse;\n+  return JSON.parse(data);\n }\n \n export const handler: Handler = async (event) => {\n   const pairId = event.queryStringParameters?.pairId;\n@@ -99,8 +99,14 @@\n     return { statusCode: 200, headers, body: JSON.stringify(body) };\n   }\n \n   log('params', { pairId, chain, poolAddress, tokenOfInterest, forceProvider, limit, windowH, gtSupported, gtNetwork });\n+  \n+  let trades: Trade[] = [];\n+  let provider: Provider | 'none' = 'none';\n+  let priceSourceHeader: 'from' | 'to' | '' = '';\n+  const cutoff = Date.now() - windowH * 3600 * 1000;\n+\n   try {\n     if (!gtNetwork) {\n       log('skip gt: invalid network', chain);\n     }\n@@ -111,15 +117,83 @@\n \n     if (USE_FIXTURES) {\n       try {\n         attempted.push('gt');\n-        const gt = await readFixture(GT_FIXTURE);\n-        gt.pairId = pairId;\n+        const gtData = await readFixture(GT_FIXTURE);\n+        const list = Array.isArray(gtData.data) ? gtData.data : [];\n+        const tradesGt = list.map((t: any) => {\n+          const attrs = t.attributes || {};\n+          // Debug: Log raw volume_in_usd value\n+          if (DEBUG && attrs.volume_in_usd) {\n+            log('fixture raw volume_in_usd:', attrs.volume_in_usd, typeof attrs.volume_in_usd);\n+          }\n+          const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n+          const side = String(attrs.kind || '').toLowerCase() === 'buy' ? 'buy' : 'sell';\n+          const toAddr = String(attrs.to_token_address || '').toLowerCase();\n+          const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n+          let price = 0;\n+          let amountBase = 0;\n+          let amountQuote = 0;\n+          let src: 'from' | 'to' = 'to';\n+          if (tokenOfInterest && tokenOfInterest === toAddr) {\n+            price = parseFloat(attrs.price_to_in_usd || '0');\n+            amountBase = parseFloat(attrs.to_token_amount || '0');\n+            amountQuote = parseFloat(attrs.from_token_amount || '0');\n+            src = 'to';\n+          } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n+            price = parseFloat(attrs.price_from_in_usd || '0');\n+            amountBase = parseFloat(attrs.from_token_amount || '0');\n+            amountQuote = parseFloat(attrs.to_token_amount || '0');\n+            src = 'from';\n+          } else if (attrs.price_to_in_usd) {\n+            price = parseFloat(attrs.price_to_in_usd || '0');\n+            amountBase = parseFloat(attrs.to_token_amount || '0');\n+            amountQuote = parseFloat(attrs.from_token_amount || '0');\n+            src = 'to';\n+          } else {\n+            price = parseFloat(attrs.price_from_in_usd || '0');\n+            amountBase = parseFloat(attrs.from_token_amount || '0');\n+            amountQuote = parseFloat(attrs.to_token_amount || '0');\n+            src = 'from';\n+          }\n+          if (!priceSourceHeader) priceSourceHeader = src;\n+          const parsedVolumeUSD = parseFloat(attrs.volume_in_usd || '0');\n+          // Debug: Log parsed volume\n+          if (DEBUG && attrs.volume_in_usd) {\n+            log('fixture parsed volumeUSD:', parsedVolumeUSD, 'from raw:', attrs.volume_in_usd);\n+          }\n+          return {\n+            ts,\n+            side,\n+            price,\n+            amountBase,\n+            amountQuote,\n+            volumeUSD: parsedVolumeUSD,\n+            txHash: attrs.tx_hash || '',\n+            wallet: attrs.tx_from_address || '',\n+          } as Trade;\n+        });\n+        trades = sanitizeTrades(\n+          tradesGt.filter((t) => t.ts * 1000 >= cutoff).slice(0, limit)\n+        );\n+        if (trades.length > 0) {\n+          provider = 'gt';\n+          log('fixture gt trades', trades.length);\n+          // Debug: Log sample volume data\n+          if (DEBUG && trades.length > 0) {\n+            log('fixture sample volumes:', trades.slice(0, 2).map(t => ({ \n+              volumeUSD: t.volumeUSD, \n+              price: t.price, \n+              amountBase: t.amountBase \n+            })));\n+          }\n+        }\n+        const bodyRes: TradesResponse = { pairId, trades, provider: provider as Provider };\n         headers['x-provider'] = 'gt';\n         headers['x-fallbacks-tried'] = attempted.join(',');\n-        headers['x-items'] = String(gt.trades.length);\n-        log('response', event.rawUrl, 200, gt.trades.length, 'gt');\n-        return { statusCode: 200, headers, body: JSON.stringify(gt) };\n+        headers['x-items'] = String(trades.length);\n+        log('response', event.rawUrl, 200, trades.length, 'gt');\n+        return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n       } catch (err) {\n         logError('fixture read failed', err);\n         headers['x-fallbacks-tried'] = attempted.join(',');\n         const body: ApiError = { error: 'upstream_error', provider: 'none' };\n@@ -127,13 +201,8 @@\n         return { statusCode: 500, headers, body: JSON.stringify(body) };\n       }\n     }\n \n-    let trades: Trade[] = [];\n-    let provider: Provider | 'none' = 'none';\n-    let priceSourceHeader: 'from' | 'to' | '' = '';\n-    const cutoff = Date.now() - windowH * 3600 * 1000;\n-\n     if (\n       (forceProvider === 'gt' || (!forceProvider && gtSupported)) &&\n       gtNetwork &&\n       validPool\n"
                }
            ],
            "date": 1755456083101,
            "name": "Commit-0",
            "content": "import type { Handler } from '@netlify/functions';\nimport type { TradesResponse, ApiError, Provider, Trade } from '../../src/lib/types';\nimport fs from 'fs/promises';\nimport { CHAIN_TO_GT_NETWORK } from '../shared/chains';\nimport { sanitizeTrades } from '../shared/agg';\n\nconst GT_FIXTURE = '../../fixtures/trades-gt.json';\n\nconst USE_FIXTURES = process.env.USE_FIXTURES === 'true';\nconst GT_API_BASE = process.env.GT_API_BASE || 'https://api.geckoterminal.com/api/v2';\nconst CG_API_BASE = process.env.COINGECKO_API_BASE || '';\nconst CG_API_KEY = process.env.COINGECKO_API_KEY || '';\nconst DEBUG = process.env.DEBUG_LOGS === 'true';\n\nfunction log(...args: any[]) {\n  if (DEBUG) console.log('[trades]', ...args);\n}\n\nfunction logError(...args: any[]) {\n  console.error('[trades]', ...args);\n}\n\nfunction isValidPair(id?: string): id is string {\n  return !!id;\n}\n\nasync function readFixture(path: string): Promise<TradesResponse> {\n  const url = new URL(path, import.meta.url);\n  const data = await fs.readFile(url, 'utf8');\n  return JSON.parse(data) as TradesResponse;\n}\n\nexport const handler: Handler = async (event) => {\n  const pairId = event.queryStringParameters?.pairId;\n  const chain = event.queryStringParameters?.chain;\n  const poolAddress = event.queryStringParameters?.poolAddress;\n  const tokenParam = event.queryStringParameters?.token;\n  const limit = Number(event.queryStringParameters?.limit) || 200;\n  const windowH = Number(event.queryStringParameters?.window) || 24;\n  const forceProvider = event.queryStringParameters?.provider as Provider | undefined;\n  const gtSupported = event.queryStringParameters?.gtSupported !== 'false';\n  const gtNetwork = chain ? CHAIN_TO_GT_NETWORK[chain] : undefined;\n  const validPool = /^0x[0-9a-fA-F]{40}$/.test(poolAddress || '');\n  const tokenOfInterest = tokenParam && /^0x[0-9a-fA-F]{40}$/.test(tokenParam)\n    ? tokenParam.toLowerCase()\n    : undefined;\n\n  const SUPPORTED_CHAINS = Object.keys(CHAIN_TO_GT_NETWORK);\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'public, max-age=30, stale-while-revalidate=60',\n    'x-provider': 'none',\n    'x-fallbacks-tried': '',\n    'x-items': '0',\n  };\n  const attempted: string[] = [];\n  if (!CG_API_KEY) attempted.push('cg:disabled');\n  if (!isValidPair(pairId) || !chain) {\n    const body: ApiError = { error: 'invalid_request', provider: 'none' };\n    log('response', event.rawUrl, 400, 0, 'none');\n    return { statusCode: 400, headers, body: JSON.stringify(body) };\n  }\n  if (!SUPPORTED_CHAINS.includes(chain)) {\n    const body: ApiError = { error: 'unsupported_network', provider: 'none' };\n    log('response', event.rawUrl, 200, 0, 'none');\n    return { statusCode: 200, headers, body: JSON.stringify(body) };\n  }\n\n  log('params', { pairId, chain, poolAddress, tokenOfInterest, forceProvider, limit, windowH, gtSupported, gtNetwork });\n  try {\n    if (!gtNetwork) {\n      log('skip gt: invalid network', chain);\n    }\n    if (!validPool) {\n      headers['x-invalid-pool'] = '1';\n      log('skip gt: invalid pool', poolAddress);\n    }\n\n    if (USE_FIXTURES) {\n      try {\n        attempted.push('gt');\n        const gt = await readFixture(GT_FIXTURE);\n        gt.pairId = pairId;\n        headers['x-provider'] = 'gt';\n        headers['x-fallbacks-tried'] = attempted.join(',');\n        headers['x-items'] = String(gt.trades.length);\n        log('response', event.rawUrl, 200, gt.trades.length, 'gt');\n        return { statusCode: 200, headers, body: JSON.stringify(gt) };\n      } catch (err) {\n        logError('fixture read failed', err);\n        headers['x-fallbacks-tried'] = attempted.join(',');\n        const body: ApiError = { error: 'upstream_error', provider: 'none' };\n        log('response', event.rawUrl, 500, 0, 'none');\n        return { statusCode: 500, headers, body: JSON.stringify(body) };\n      }\n    }\n\n    let trades: Trade[] = [];\n    let provider: Provider | 'none' = 'none';\n    let priceSourceHeader: 'from' | 'to' | '' = '';\n    const cutoff = Date.now() - windowH * 3600 * 1000;\n\n    if (\n      (forceProvider === 'gt' || (!forceProvider && gtSupported)) &&\n      gtNetwork &&\n      validPool\n    ) {\n      attempted.push('gt');\n      try {\n        const gtUrl = `${GT_API_BASE}/networks/${gtNetwork}/pools/${poolAddress}/trades?limit=${limit}`;\n        const gtResp = await fetch(gtUrl);\n        if (gtResp.ok) {\n          const gtData = await gtResp.json();\n          const list = Array.isArray(gtData.data) ? gtData.data : [];\n          const tradesGt = list.map((t: any) => {\n            const attrs = t.attributes || {};\n            const ts = Math.floor(Date.parse(attrs.block_timestamp) / 1000);\n            const side = String(attrs.kind).toLowerCase() === 'buy' ? 'buy' : 'sell';\n            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n            let price = 0;\n            let amountBase = 0;\n            let amountQuote = 0;\n            let src: 'from' | 'to' = 'to';\n            if (tokenOfInterest && tokenOfInterest === toAddr) {\n              price = Number(attrs.price_to_in_usd ?? 0);\n              amountBase = Number(attrs.to_token_amount ?? 0);\n              amountQuote = Number(attrs.from_token_amount ?? 0);\n              src = 'to';\n            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n              price = Number(attrs.price_from_in_usd ?? 0);\n              amountBase = Number(attrs.from_token_amount ?? 0);\n              amountQuote = Number(attrs.to_token_amount ?? 0);\n              src = 'from';\n            } else if (attrs.price_to_in_usd !== undefined) {\n              price = Number(attrs.price_to_in_usd ?? 0);\n              amountBase = Number(attrs.to_token_amount ?? 0);\n              amountQuote = Number(attrs.from_token_amount ?? 0);\n              src = 'to';\n            } else {\n              price = Number(attrs.price_from_in_usd ?? 0);\n              amountBase = Number(attrs.from_token_amount ?? 0);\n              amountQuote = Number(attrs.to_token_amount ?? 0);\n              src = 'from';\n            }\n            if (!priceSourceHeader) priceSourceHeader = src;\n            return {\n              ts,\n              side,\n              price,\n              amountBase,\n              amountQuote,\n              txHash: attrs.tx_hash,\n              wallet: attrs.tx_from_address,\n            } as Trade;\n          });\n          trades = sanitizeTrades(\n            tradesGt.filter((t) => t.ts * 1000 >= cutoff).slice(0, limit)\n          );\n          if (trades.length > 0) {\n            provider = 'gt';\n            log('gt trades', trades.length);\n          }\n        }\n      } catch (err) {\n        logError('gt trades fetch failed', err);\n        // ignore\n      }\n    }\n\n    if (trades.length === 0 && (forceProvider !== 'gt') && CG_API_BASE && CG_API_KEY && chain && poolAddress) {\n      attempted.push('cg');\n      try {\n        const cgUrl = `${CG_API_BASE}/pool-trades-contract-address?chain=${chain}&address=${poolAddress}&limit=300`;\n        const res = await fetch(cgUrl, {\n          headers: { 'x-cg-pro-api-key': CG_API_KEY },\n        });\n        if (res.status === 401 || res.status === 403) {\n          headers['x-cg-auth'] = 'fail';\n          log('cg auth fail', res.status);\n        }\n        if (res.ok) {\n          const cg = await res.json();\n          const list = Array.isArray(cg?.data)\n            ? cg.data\n            : Array.isArray(cg?.trades)\n            ? cg.trades\n            : Array.isArray(cg)\n            ? cg\n            : [];\n          const tradesCg = list.map((t: any) => {\n            const attrs = t.attributes || t;\n            const tsRaw = attrs.timestamp ?? attrs.ts ?? attrs.time ?? attrs[0];\n            let ts = Number(tsRaw);\n            if (!Number.isFinite(ts)) {\n              ts = Math.floor(Date.parse(String(tsRaw)) / 1000);\n            }\n            const sideRaw = attrs.kind ?? attrs.trade_type ?? attrs.side ?? attrs.type ?? '';\n            const toAddr = String(attrs.to_token_address || '').toLowerCase();\n            const fromAddr = String(attrs.from_token_address || '').toLowerCase();\n            let price = 0;\n            let amountBase = 0;\n            let amountQuote = 0;\n            let src: 'from' | 'to' = 'to';\n            if (tokenOfInterest && tokenOfInterest === toAddr) {\n              price = Number(\n                attrs.price_to_in_usd ??\n                  attrs.price_usd ??\n                  attrs.priceUsd ??\n                  attrs.price ??\n                  attrs[1] ??\n                  0\n              );\n              amountBase = Number(\n                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n              );\n              amountQuote = Number(\n                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n              );\n              src = 'to';\n            } else if (tokenOfInterest && tokenOfInterest === fromAddr) {\n              price = Number(\n                attrs.price_from_in_usd ??\n                  attrs.price_usd ??\n                  attrs.priceUsd ??\n                  attrs.price ??\n                  attrs[1] ??\n                  0\n              );\n              amountBase = Number(\n                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n              );\n              amountQuote = Number(\n                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n              );\n              src = 'from';\n            } else if (attrs.price_to_in_usd !== undefined) {\n              price = Number(\n                attrs.price_to_in_usd ??\n                  attrs.price_usd ??\n                  attrs.priceUsd ??\n                  attrs.price ??\n                  attrs[1] ??\n                  0\n              );\n              amountBase = Number(\n                attrs.to_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n              );\n              amountQuote = Number(\n                attrs.from_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n              );\n              src = 'to';\n            } else {\n              price = Number(\n                attrs.price_from_in_usd ??\n                  attrs.price_usd ??\n                  attrs.priceUsd ??\n                  attrs.price ??\n                  attrs[1] ??\n                  0\n              );\n              amountBase = Number(\n                attrs.from_token_amount ?? attrs.amount_base ?? attrs.amount_base_token ?? 0\n              );\n              amountQuote = Number(\n                attrs.to_token_amount ?? attrs.amount_quote ?? attrs.amount_quote_token ?? 0\n              );\n              src = 'from';\n            }\n            if (!priceSourceHeader) priceSourceHeader = src;\n            return {\n              ts,\n              side: String(sideRaw).toLowerCase() === 'sell' ? 'sell' : 'buy',\n              price,\n              amountBase,\n              amountQuote,\n              txHash: attrs.tx_hash || attrs.txHash,\n              wallet: attrs.tx_from_address || attrs.wallet || attrs.address,\n            } as Trade;\n          });\n          trades = sanitizeTrades(\n            tradesCg.filter((t: Trade) => t.ts * 1000 >= cutoff).slice(0, limit)\n          );\n          if (trades.length > 0) {\n            provider = 'cg';\n            log('cg trades', trades.length);\n          }\n        }\n      } catch (err) {\n        logError('cg trades fetch failed', err);\n        // ignore and fall through\n      }\n    }\n\n    const bodyRes: TradesResponse = { pairId, trades, provider: provider as Provider };\n    headers['x-provider'] = provider;\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    headers['x-items'] = String(trades.length);\n    if (tokenOfInterest) headers['x-token'] = tokenOfInterest;\n    if (priceSourceHeader) headers['x-price-source'] = priceSourceHeader;\n    log('response', event.rawUrl, 200, trades.length, provider);\n    return { statusCode: 200, headers, body: JSON.stringify(bodyRes) };\n  } catch (err) {\n    logError('handler error', err);\n    headers['x-fallbacks-tried'] = attempted.join(',');\n    const body: ApiError = { error: 'internal_error', provider: 'none' };\n    return { statusCode: 500, headers, body: JSON.stringify(body) };\n  }\n};\n\n"
        }
    ]
}