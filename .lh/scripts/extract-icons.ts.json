{
    "sourceFile": "scripts/extract-icons.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755522092648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755522092648,
            "name": "Commit-0",
            "content": "#!/usr/bin/env ts-node\n\nimport { readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\n\ninterface ChainIcon {\n  name: string;\n  id: string;\n  url: string;\n}\n\ninterface DexIcon {\n  name: string;\n  id: string;\n  url: string;\n}\n\nfunction extractChainIcons(htmlContent: string): ChainIcon[] {\n  const icons: ChainIcon[] = [];\n  \n  // Regex to match chain entries with href and img src\n  const chainRegex = /href=\"\\/en\\/chains\\/([^\"]+)\"[^>]*>[\\s\\S]*?<img[^>]+alt=\"([^\"]+)\"[^>]+src=\"([^\"?]+)/g;\n  \n  let match;\n  while ((match = chainRegex.exec(htmlContent)) !== null) {\n    const [, id, name, url] = match;\n    \n    // Skip if this looks like a coin/token (contains \"top gainers\" context)\n    const contextBefore = htmlContent.substring(Math.max(0, match.index - 200), match.index);\n    if (contextBefore.includes('Top Gainers') || contextBefore.includes('top gainers')) {\n      continue;\n    }\n    \n    // Clean up the URL and name\n    const cleanUrl = url.trim();\n    const cleanName = name.trim();\n    const cleanId = id.trim();\n    \n    // Only add if this looks like a chain icon URL\n    if (cleanUrl.includes('asset_platforms') || cleanUrl.includes('chains')) {\n      icons.push({\n        name: cleanName,\n        id: cleanId,\n        url: cleanUrl\n      });\n    }\n  }\n  \n  // Remove duplicates based on ID\n  const uniqueIcons = icons.reduce((acc, current) => {\n    const existing = acc.find(icon => icon.id === current.id);\n    if (!existing) {\n      acc.push(current);\n    }\n    return acc;\n  }, [] as ChainIcon[]);\n  \n  return uniqueIcons.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction extractDexIcons(htmlContent: string): DexIcon[] {\n  const icons: DexIcon[] = [];\n  \n  // Regex to match DEX entries with alt and img src\n  const dexRegex = /<img[^>]+alt=\"([^\"]+)\"[^>]+src=\"([^\"?]+)[^>]*>/g;\n  \n  let match;\n  while ((match = dexRegex.exec(htmlContent)) !== null) {\n    const [, name, url] = match;\n    \n    // Clean up the URL and name\n    const cleanUrl = url.trim();\n    const cleanName = name.trim();\n    \n    // Only add if this looks like a DEX icon URL (should be in markets/images)\n    if (cleanUrl.includes('markets/images') && cleanUrl.includes('coingecko.com')) {\n      // Extract ID from the URL path\n      const urlMatch = cleanUrl.match(/markets\\/images\\/(\\d+)\\//);\n      const id = urlMatch ? urlMatch[1] : cleanName.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n      \n      icons.push({\n        name: cleanName,\n        id,\n        url: cleanUrl\n      });\n    }\n  }\n  \n  // Remove duplicates based on name\n  const uniqueIcons = icons.reduce((acc, current) => {\n    const existing = acc.find(icon => icon.name === current.name);\n    if (!existing) {\n      acc.push(current);\n    }\n    return acc;\n  }, [] as DexIcon[]);\n  \n  return uniqueIcons.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction generateIconsMapping(chains: ChainIcon[], dexes: DexIcon[]) {\n  const chainMapping: Record<string, string> = {};\n  const dexMapping: Record<string, string> = {};\n  \n  // Create chain mapping\n  for (const chain of chains) {\n    chainMapping[chain.id] = chain.url;\n    // Also add common variations\n    const variations = [\n      chain.name.toLowerCase(),\n      chain.name.toLowerCase().replace(/\\s+/g, '-'),\n      chain.name.toLowerCase().replace(/\\s+/g, '_'),\n      chain.name.toLowerCase().replace(/[^a-z0-9]/g, ''),\n    ];\n    for (const variation of variations) {\n      if (!chainMapping[variation]) {\n        chainMapping[variation] = chain.url;\n      }\n    }\n  }\n  \n  // Create DEX mapping\n  for (const dex of dexes) {\n    const dexKey = dex.name.toLowerCase()\n      .replace(/\\s*\\([^)]*\\)/g, '') // Remove parentheses content like (BSC)\n      .replace(/\\s+v\\d+/i, '') // Remove version numbers like V3\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '');\n    \n    dexMapping[dexKey] = dex.url;\n    dexMapping[dex.id] = dex.url;\n    \n    // Also add the full name as key\n    const fullKey = dex.name.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n    dexMapping[fullKey] = dex.url;\n  }\n  \n  return { chainMapping, dexMapping };\n}\n\nasync function main() {\n  const docsDir = join(process.cwd(), 'docs');\n  const srcDir = join(process.cwd(), 'src');\n  \n  try {\n    console.log('üìñ Reading coingecko data files...');\n    \n    // Read the markdown files\n    const chainsContent = readFileSync(join(docsDir, 'coingecko_chains.md'), 'utf-8');\n    const dexesContent = readFileSync(join(docsDir, 'coingecko_dexes.md'), 'utf-8');\n    \n    console.log('üîç Extracting chain icons...');\n    const chains = extractChainIcons(chainsContent);\n    console.log(`   Found ${chains.length} chain icons`);\n    \n    console.log('üîç Extracting DEX icons...');\n    const dexes = extractDexIcons(dexesContent);\n    console.log(`   Found ${dexes.length} DEX icons`);\n    \n    console.log('üîß Generating icon mappings...');\n    const { chainMapping, dexMapping } = generateIconsMapping(chains, dexes);\n    \n    // Generate the icons data\n    const iconsData = {\n      chains: chainMapping,\n      dexes: dexMapping,\n      metadata: {\n        generated: new Date().toISOString(),\n        chainCount: chains.length,\n        dexCount: dexes.length\n      }\n    };\n    \n    // Save the icons data as JSON\n    const iconsJsonPath = join(srcDir, 'lib', 'icons-data.json');\n    writeFileSync(iconsJsonPath, JSON.stringify(iconsData, null, 2));\n    console.log(`‚úÖ Icons data saved to ${iconsJsonPath}`);\n    \n    // Generate debug output\n    const debugPath = join(process.cwd(), 'extracted-icons-debug.json');\n    writeFileSync(debugPath, JSON.stringify({\n      chains: chains.map(c => ({ ...c, variations: [c.id, c.name.toLowerCase(), c.name.toLowerCase().replace(/\\s+/g, '-')] })),\n      dexes: dexes.map(d => ({ ...d, key: d.name.toLowerCase().replace(/\\s*\\([^)]*\\)/g, '').replace(/\\s+v\\d+/i, '').replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '') }))\n    }, null, 2));\n    console.log(`üêõ Debug data saved to ${debugPath}`);\n    \n    console.log('\\nüìä Summary:');\n    console.log(`   Chain icons: ${chains.length}`);\n    console.log(`   DEX icons: ${dexes.length}`);\n    console.log(`   Chain mappings: ${Object.keys(chainMapping).length}`);\n    console.log(`   DEX mappings: ${Object.keys(dexMapping).length}`);\n    \n    // Show some examples\n    console.log('\\nüîç Sample chain mappings:');\n    Object.entries(chainMapping).slice(0, 5).forEach(([key, url]) => {\n      console.log(`   ${key} -> ${url}`);\n    });\n    \n    console.log('\\nüîç Sample DEX mappings:');\n    Object.entries(dexMapping).slice(0, 5).forEach(([key, url]) => {\n      console.log(`   ${key} -> ${url}`);\n    });\n    \n  } catch (error) {\n    console.error('‚ùå Error extracting icons:', error);\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n"
        }
    ]
}