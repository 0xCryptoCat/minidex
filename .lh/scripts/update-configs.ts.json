{
    "sourceFile": "scripts/update-configs.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1755455168884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755455251334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n };\n \n // Networks that should be prioritized (top tier by volume/usage)\n const PRIORITY_NETWORKS = new Set([\n-  'eth', , 'bsc', 'polygon_pos', 'avax', 'arbitrum', 'optimism', \n+  'eth', '', 'bsc', 'polygon_pos', 'avax', 'arbitrum', 'optimism', \n   'base', 'ftm', 'linea', 'scroll', 'zksync', 'mantle'\n ]);\n \n /**\n"
                },
                {
                    "date": 1755455354151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,315 @@\n+#!/usr/bin/env tsx\n+\n+/**\n+ * Script to process GT networks/dexes data and update SmallDEX configurations\n+ * Expands support for all GT networks and DEXes\n+ */\n+\n+import fs from 'fs/promises';\n+import path from 'path';\n+\n+interface GTNetwork {\n+  id: string;\n+  name: string;\n+  coingecko_asset_platform_id: string | null;\n+  dexes: Array<{\n+    id: string;\n+    name: string;\n+  }>;\n+}\n+\n+interface GTData {\n+  generated_at: string;\n+  source: string;\n+  total_networks: number;\n+  total_dexes: number;\n+  networks: GTNetwork[];\n+}\n+\n+// Manual mapping for GT network ID to common chain names used in SmallDEX\n+const GT_TO_CHAIN_MAPPING: Record<string, string> = {\n+  'eth': 'ethereum',\n+  'bsc': 'bsc',\n+  'polygon_pos': 'polygon',\n+  'avax': 'avalanche', \n+  'arbitrum': 'arbitrum',\n+  'optimism': 'optimism',\n+  'ftm': 'fantom',\n+  'base': 'base',\n+  'linea': 'linea',\n+  'scroll': 'scroll',\n+  'zksync': 'zksync',\n+  'polygon-zkevm': 'polygon-zkevm',\n+  'mantle': 'mantle',\n+  'arbitrum_nova': 'arbitrum-nova',\n+  'xdai': 'gnosis',\n+  'glmr': 'moonbeam',\n+  'movr': 'moonriver',\n+  'cro': 'cronos',\n+  'one': 'harmony',\n+  'celo': 'celo',\n+  'aurora': 'aurora',\n+  'metis': 'metis',\n+  'boba': 'boba',\n+  'kava': 'kava',\n+  'solana': 'solana',\n+  'aptos': 'aptos',\n+  'sui-network': 'sui',\n+  // Add more mappings as needed\n+};\n+\n+// Networks that should be prioritized (top tier by volume/usage)\n+const PRIORITY_NETWORKS = new Set([\n+  'eth', 'solana', 'bsc', 'polygon_pos', 'avax', 'arbitrum', 'optimism', \n+  'base', 'ftm', 'linea', 'scroll', 'zksync'\n+]);\n+\n+/**\n+ * Load the fetched GT data\n+ */\n+async function loadGTData(): Promise<GTData> {\n+  const dataPath = path.join(process.cwd(), 'data', 'gt-networks-dexes.json');\n+  const content = await fs.readFile(dataPath, 'utf-8');\n+  return JSON.parse(content);\n+}\n+\n+/**\n+ * Generate updated chains.ts file\n+ */\n+async function updateChainsConfig(data: GTData): Promise<void> {\n+  console.log('üîó Updating chains configuration...');\n+  \n+  const chainMappings: Record<string, string> = {};\n+  const priorityNetworks: string[] = [];\n+  const allNetworks: string[] = [];\n+  \n+  // Process networks and create mappings\n+  for (const network of data.networks) {\n+    // Convert GT network ID to valid JS property name\n+    const chainName = GT_TO_CHAIN_MAPPING[network.id] || \n+      network.id.replace(/[_-]/g, '').replace(/[^a-zA-Z0-9]/g, '');\n+    chainMappings[chainName] = network.id;\n+    allNetworks.push(chainName);\n+    \n+    if (PRIORITY_NETWORKS.has(network.id)) {\n+      priorityNetworks.push(chainName);\n+    }\n+  }\n+  \n+  // Generate the new chains.ts content\n+  const chainsContent = `/**\n+ * Chain to GeckoTerminal network mapping\n+ * Auto-generated from GT API data on ${new Date().toISOString()}\n+ * \n+ * Total networks: ${data.total_networks}\n+ * Total DEXes: ${data.total_dexes}\n+ */\n+\n+// Priority networks (high volume/usage)\n+export const PRIORITY_CHAINS = [\n+${priorityNetworks.map(chain => `  '${chain}',`).join('\\n')}\n+] as const;\n+\n+// Complete chain to GT network mapping\n+export const CHAIN_TO_GT_NETWORK: Record<string, string> = {\n+${Object.entries(chainMappings)\n+  .sort(([a], [b]) => {\n+    // Sort priority chains first, then alphabetically\n+    const aPriority = priorityNetworks.includes(a);\n+    const bPriority = priorityNetworks.includes(b);\n+    if (aPriority && !bPriority) return -1;\n+    if (!aPriority && bPriority) return 1;\n+    return a.localeCompare(b);\n+  })\n+  .map(([chain, gtNetwork]) => `  ${chain}: '${gtNetwork}',${priorityNetworks.includes(chain) ? ' // Priority' : ''}`)\n+  .join('\\n')}\n+};\n+\n+export const SUPPORTED_GT_NETWORKS = new Set(Object.values(CHAIN_TO_GT_NETWORK));\n+\n+export type GTNetwork = (typeof CHAIN_TO_GT_NETWORK)[keyof typeof CHAIN_TO_GT_NETWORK];\n+\n+export function toGTNetwork(chain: string): GTNetwork | null {\n+  return (CHAIN_TO_GT_NETWORK as Record<string, GTNetwork>)[chain] ?? null;\n+}\n+\n+export function isPriorityChain(chain: string): boolean {\n+  return PRIORITY_CHAINS.includes(chain as any);\n+}\n+\n+// Network metadata for display purposes\n+export const NETWORK_INFO: Record<string, { name: string; platformId?: string }> = {\n+${data.networks\n+  .map(network => {\n+    const chainName = GT_TO_CHAIN_MAPPING[network.id] || \n+      network.id.replace(/[_-]/g, '').replace(/[^a-zA-Z0-9]/g, '');\n+    return `  ${chainName}: { name: '${network.name}', platformId: ${network.coingecko_asset_platform_id ? `'${network.coingecko_asset_platform_id}'` : 'undefined'} },`;\n+  })\n+  .sort()\n+  .join('\\n')}\n+};\n+`;\n+\n+  // Write the updated chains.ts file\n+  const chainsPath = path.join(process.cwd(), 'netlify', 'shared', 'chains.ts');\n+  await fs.writeFile(chainsPath, chainsContent);\n+  \n+  console.log(`‚úÖ Updated chains.ts with ${Object.keys(chainMappings).length} networks`);\n+}\n+\n+/**\n+ * Generate updated dex-allow.ts file\n+ */\n+async function updateDexAllowConfig(data: GTData): Promise<void> {\n+  console.log('üè™ Updating DEX allowlist configuration...');\n+  \n+  const allDexes = new Set<string>();\n+  const dexesByNetwork: Record<string, string[]> = {};\n+  \n+  // Collect all DEXes and organize by network\n+  for (const network of data.networks) {\n+    dexesByNetwork[network.id] = [];\n+    for (const dex of network.dexes) {\n+      allDexes.add(dex.id);\n+      dexesByNetwork[network.id].push(dex.id);\n+    }\n+  }\n+  \n+  // Generate the new dex-allow.ts content\n+  const dexAllowContent = `/**\n+ * DEX allowlist for GeckoTerminal API support\n+ * Auto-generated from GT API data on ${new Date().toISOString()}\n+ * \n+ * Total networks: ${data.total_networks}\n+ * Total unique DEXes: ${allDexes.size}\n+ */\n+\n+// All supported DEXes across all networks\n+export const ALLOW = new Set([\n+${Array.from(allDexes)\n+  .sort()\n+  .map(dex => `  '${dex}',`)\n+  .join('\\n')}\n+]);\n+\n+// Priority DEXes (commonly used across multiple networks)\n+export const PRIORITY_DEXES = new Set([\n+  'uniswap_v2',\n+  'uniswap_v3', \n+  'sushiswap',\n+  'pancakeswap_v2',\n+  'pancakeswap_v3',\n+  'quickswap',\n+  'trader_joe_v2',\n+  'spookyswap',\n+  'spiritswap',\n+  'curve',\n+  'balancer_v2',\n+  'orca',\n+  'raydium',\n+]);\n+\n+// DEXes by network for filtering/display\n+export const DEXES_BY_NETWORK: Record<string, string[]> = {\n+${Object.entries(dexesByNetwork)\n+  .sort(([a], [b]) => a.localeCompare(b))\n+  .map(([network, dexes]) => `  ${network}: [${dexes.map(d => `'${d}'`).join(', ')}],`)\n+  .join('\\n')}\n+};\n+\n+export function isGtSupported(dex?: string, version?: string): boolean {\n+  if (!dex) return false;\n+  const key = \\`\\${dex.toLowerCase()}\\${version ? '_' + version.toLowerCase() : ''}\\`;\n+  return ALLOW.has(key);\n+}\n+\n+export function isPriorityDex(dex: string): boolean {\n+  return PRIORITY_DEXES.has(dex);\n+}\n+\n+export function getDexesForNetwork(network: string): string[] {\n+  return DEXES_BY_NETWORK[network] || [];\n+}\n+\n+export function getNetworksForDex(dexId: string): string[] {\n+  return Object.entries(DEXES_BY_NETWORK)\n+    .filter(([_, dexes]) => dexes.includes(dexId))\n+    .map(([network]) => network);\n+}\n+`;\n+\n+  // Write the updated dex-allow.ts file\n+  const dexAllowPath = path.join(process.cwd(), 'netlify', 'shared', 'dex-allow.ts');\n+  await fs.writeFile(dexAllowPath, dexAllowContent);\n+  \n+  console.log(`‚úÖ Updated dex-allow.ts with ${allDexes.size} DEXes across ${data.networks.length} networks`);\n+}\n+\n+/**\n+ * Generate network statistics and summary\n+ */\n+async function generateNetworkSummary(data: GTData): Promise<void> {\n+  console.log('üìä Generating network summary...');\n+  \n+  const summaryPath = path.join(process.cwd(), 'data', 'network-summary.json');\n+  \n+  const summary = {\n+    generated_at: new Date().toISOString(),\n+    total_networks: data.total_networks,\n+    total_dexes: data.total_dexes,\n+    priority_networks: data.networks.filter(n => PRIORITY_NETWORKS.has(n.id)).length,\n+    top_networks_by_dexes: data.networks\n+      .sort((a, b) => b.dexes.length - a.dexes.length)\n+      .slice(0, 20)\n+      .map(n => ({\n+        id: n.id,\n+        name: n.name,\n+        dex_count: n.dexes.length,\n+        is_priority: PRIORITY_NETWORKS.has(n.id)\n+      })),\n+    dex_distribution: {\n+      networks_with_50_plus_dexes: data.networks.filter(n => n.dexes.length >= 50).length,\n+      networks_with_20_plus_dexes: data.networks.filter(n => n.dexes.length >= 20).length,\n+      networks_with_10_plus_dexes: data.networks.filter(n => n.dexes.length >= 10).length,\n+      networks_with_single_dex: data.networks.filter(n => n.dexes.length === 1).length,\n+    }\n+  };\n+  \n+  await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));\n+  console.log(`‚úÖ Generated network summary at ${summaryPath}`);\n+}\n+\n+/**\n+ * Main function\n+ */\n+async function main() {\n+  console.log('üöÄ Processing GeckoTerminal data for SmallDEX integration...\\n');\n+  \n+  try {\n+    // Load the fetched data\n+    const data = await loadGTData();\n+    console.log(`üìà Loaded data: ${data.total_networks} networks, ${data.total_dexes} DEXes\\n`);\n+    \n+    // Update configurations\n+    await updateChainsConfig(data);\n+    await updateDexAllowConfig(data);\n+    await generateNetworkSummary(data);\n+    \n+    console.log('\\n‚úÖ SmallDEX GT integration complete!');\n+    console.log('üìã Summary:');\n+    console.log(`   ‚Ä¢ Supported networks: ${data.total_networks}`);\n+    console.log(`   ‚Ä¢ Supported DEXes: ${data.total_dexes}`);\n+    console.log(`   ‚Ä¢ Updated files:`);\n+    console.log(`     - netlify/shared/chains.ts`);\n+    console.log(`     - netlify/shared/dex-allow.ts`);\n+    console.log(`     - data/network-summary.json`);\n+    \n+  } catch (error) {\n+    console.error('‚ùå Fatal error:', error);\n+    process.exit(1);\n+  }\n+}\n+\n+if (require.main === module) {\n+  main();\n+}\n"
                }
            ],
            "date": 1755455168884,
            "name": "Commit-0",
            "content": "#!/usr/bin/env tsx\n\n/**\n * Script to process GT networks/dexes data and update SmallDEX configurations\n * Expands support for all GT networks and DEXes\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\n\ninterface GTNetwork {\n  id: string;\n  name: string;\n  coingecko_asset_platform_id: string | null;\n  dexes: Array<{\n    id: string;\n    name: string;\n  }>;\n}\n\ninterface GTData {\n  generated_at: string;\n  source: string;\n  total_networks: number;\n  total_dexes: number;\n  networks: GTNetwork[];\n}\n\n// Manual mapping for GT network ID to common chain names used in SmallDEX\nconst GT_TO_CHAIN_MAPPING: Record<string, string> = {\n  'eth': 'ethereum',\n  'bsc': 'bsc',\n  'polygon_pos': 'polygon',\n  'avax': 'avalanche', \n  'arbitrum': 'arbitrum',\n  'optimism': 'optimism',\n  'ftm': 'fantom',\n  'base': 'base',\n  'linea': 'linea',\n  'scroll': 'scroll',\n  'zksync': 'zksync',\n  'polygon-zkevm': 'polygon-zkevm',\n  'mantle': 'mantle',\n  'arbitrum_nova': 'arbitrum-nova',\n  'xdai': 'gnosis',\n  'glmr': 'moonbeam',\n  'movr': 'moonriver',\n  'cro': 'cronos',\n  'one': 'harmony',\n  'celo': 'celo',\n  'aurora': 'aurora',\n  'metis': 'metis',\n  'boba': 'boba',\n  'kava': 'kava',\n  'solana': 'solana',\n  'aptos': 'aptos',\n  'sui-network': 'sui',\n  // Add more mappings as needed\n};\n\n// Networks that should be prioritized (top tier by volume/usage)\nconst PRIORITY_NETWORKS = new Set([\n  'eth', 'bsc', 'polygon_pos', 'avax', 'arbitrum', 'optimism', \n  'base', 'ftm', 'linea', 'scroll', 'zksync', 'mantle'\n]);\n\n/**\n * Load the fetched GT data\n */\nasync function loadGTData(): Promise<GTData> {\n  const dataPath = path.join(process.cwd(), 'data', 'gt-networks-dexes.json');\n  const content = await fs.readFile(dataPath, 'utf-8');\n  return JSON.parse(content);\n}\n\n/**\n * Generate updated chains.ts file\n */\nasync function updateChainsConfig(data: GTData): Promise<void> {\n  console.log('üîó Updating chains configuration...');\n  \n  const chainMappings: Record<string, string> = {};\n  const priorityNetworks: string[] = [];\n  const allNetworks: string[] = [];\n  \n  // Process networks and create mappings\n  for (const network of data.networks) {\n    const chainName = GT_TO_CHAIN_MAPPING[network.id] || network.id.replace(/[_-]/g, '');\n    chainMappings[chainName] = network.id;\n    allNetworks.push(chainName);\n    \n    if (PRIORITY_NETWORKS.has(network.id)) {\n      priorityNetworks.push(chainName);\n    }\n  }\n  \n  // Generate the new chains.ts content\n  const chainsContent = `/**\n * Chain to GeckoTerminal network mapping\n * Auto-generated from GT API data on ${new Date().toISOString()}\n * \n * Total networks: ${data.total_networks}\n * Total DEXes: ${data.total_dexes}\n */\n\n// Priority networks (high volume/usage)\nexport const PRIORITY_CHAINS = [\n${priorityNetworks.map(chain => `  '${chain}',`).join('\\n')}\n] as const;\n\n// Complete chain to GT network mapping\nexport const CHAIN_TO_GT_NETWORK: Record<string, string> = {\n${Object.entries(chainMappings)\n  .sort(([a], [b]) => {\n    // Sort priority chains first, then alphabetically\n    const aPriority = priorityNetworks.includes(a);\n    const bPriority = priorityNetworks.includes(b);\n    if (aPriority && !bPriority) return -1;\n    if (!aPriority && bPriority) return 1;\n    return a.localeCompare(b);\n  })\n  .map(([chain, gtNetwork]) => `  ${chain}: '${gtNetwork}',${priorityNetworks.includes(chain) ? ' // Priority' : ''}`)\n  .join('\\n')}\n};\n\nexport const SUPPORTED_GT_NETWORKS = new Set(Object.values(CHAIN_TO_GT_NETWORK));\n\nexport type GTNetwork = (typeof CHAIN_TO_GT_NETWORK)[keyof typeof CHAIN_TO_GT_NETWORK];\n\nexport function toGTNetwork(chain: string): GTNetwork | null {\n  return (CHAIN_TO_GT_NETWORK as Record<string, GTNetwork>)[chain] ?? null;\n}\n\nexport function isPriorityChain(chain: string): boolean {\n  return PRIORITY_CHAINS.includes(chain as any);\n}\n\n// Network metadata for display purposes\nexport const NETWORK_INFO: Record<string, { name: string; platformId?: string }> = {\n${data.networks\n  .map(network => {\n    const chainName = GT_TO_CHAIN_MAPPING[network.id] || network.id.replace(/[_-]/g, '');\n    return `  ${chainName}: { name: '${network.name}', platformId: ${network.coingecko_asset_platform_id ? `'${network.coingecko_asset_platform_id}'` : 'undefined'} },`;\n  })\n  .sort()\n  .join('\\n')}\n};\n`;\n\n  // Write the updated chains.ts file\n  const chainsPath = path.join(process.cwd(), 'netlify', 'shared', 'chains.ts');\n  await fs.writeFile(chainsPath, chainsContent);\n  \n  console.log(`‚úÖ Updated chains.ts with ${Object.keys(chainMappings).length} networks`);\n}\n\n/**\n * Generate updated dex-allow.ts file\n */\nasync function updateDexAllowConfig(data: GTData): Promise<void> {\n  console.log('üè™ Updating DEX allowlist configuration...');\n  \n  const allDexes = new Set<string>();\n  const dexesByNetwork: Record<string, string[]> = {};\n  \n  // Collect all DEXes and organize by network\n  for (const network of data.networks) {\n    dexesByNetwork[network.id] = [];\n    for (const dex of network.dexes) {\n      allDexes.add(dex.id);\n      dexesByNetwork[network.id].push(dex.id);\n    }\n  }\n  \n  // Generate the new dex-allow.ts content\n  const dexAllowContent = `/**\n * DEX allowlist for GeckoTerminal API support\n * Auto-generated from GT API data on ${new Date().toISOString()}\n * \n * Total networks: ${data.total_networks}\n * Total unique DEXes: ${allDexes.size}\n */\n\n// All supported DEXes across all networks\nexport const ALLOW = new Set([\n${Array.from(allDexes)\n  .sort()\n  .map(dex => `  '${dex}',`)\n  .join('\\n')}\n]);\n\n// Priority DEXes (commonly used across multiple networks)\nexport const PRIORITY_DEXES = new Set([\n  'uniswap_v2',\n  'uniswap_v3', \n  'sushiswap',\n  'pancakeswap_v2',\n  'pancakeswap_v3',\n  'quickswap',\n  'trader_joe_v2',\n  'spookyswap',\n  'spiritswap',\n  'curve',\n  'balancer_v2',\n  'orca',\n  'raydium',\n]);\n\n// DEXes by network for filtering/display\nexport const DEXES_BY_NETWORK: Record<string, string[]> = {\n${Object.entries(dexesByNetwork)\n  .sort(([a], [b]) => a.localeCompare(b))\n  .map(([network, dexes]) => `  ${network}: [${dexes.map(d => `'${d}'`).join(', ')}],`)\n  .join('\\n')}\n};\n\nexport function isGtSupported(dex?: string, version?: string): boolean {\n  if (!dex) return false;\n  const key = \\`\\${dex.toLowerCase()}\\${version ? '_' + version.toLowerCase() : ''}\\`;\n  return ALLOW.has(key);\n}\n\nexport function isPriorityDex(dex: string): boolean {\n  return PRIORITY_DEXES.has(dex);\n}\n\nexport function getDexesForNetwork(network: string): string[] {\n  return DEXES_BY_NETWORK[network] || [];\n}\n\nexport function getNetworksForDex(dexId: string): string[] {\n  return Object.entries(DEXES_BY_NETWORK)\n    .filter(([_, dexes]) => dexes.includes(dexId))\n    .map(([network]) => network);\n}\n`;\n\n  // Write the updated dex-allow.ts file\n  const dexAllowPath = path.join(process.cwd(), 'netlify', 'shared', 'dex-allow.ts');\n  await fs.writeFile(dexAllowPath, dexAllowContent);\n  \n  console.log(`‚úÖ Updated dex-allow.ts with ${allDexes.size} DEXes across ${data.networks.length} networks`);\n}\n\n/**\n * Generate network statistics and summary\n */\nasync function generateNetworkSummary(data: GTData): Promise<void> {\n  console.log('üìä Generating network summary...');\n  \n  const summaryPath = path.join(process.cwd(), 'data', 'network-summary.json');\n  \n  const summary = {\n    generated_at: new Date().toISOString(),\n    total_networks: data.total_networks,\n    total_dexes: data.total_dexes,\n    priority_networks: data.networks.filter(n => PRIORITY_NETWORKS.has(n.id)).length,\n    top_networks_by_dexes: data.networks\n      .sort((a, b) => b.dexes.length - a.dexes.length)\n      .slice(0, 20)\n      .map(n => ({\n        id: n.id,\n        name: n.name,\n        dex_count: n.dexes.length,\n        is_priority: PRIORITY_NETWORKS.has(n.id)\n      })),\n    dex_distribution: {\n      networks_with_50_plus_dexes: data.networks.filter(n => n.dexes.length >= 50).length,\n      networks_with_20_plus_dexes: data.networks.filter(n => n.dexes.length >= 20).length,\n      networks_with_10_plus_dexes: data.networks.filter(n => n.dexes.length >= 10).length,\n      networks_with_single_dex: data.networks.filter(n => n.dexes.length === 1).length,\n    }\n  };\n  \n  await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));\n  console.log(`‚úÖ Generated network summary at ${summaryPath}`);\n}\n\n/**\n * Main function\n */\nasync function main() {\n  console.log('üöÄ Processing GeckoTerminal data for SmallDEX integration...\\n');\n  \n  try {\n    // Load the fetched data\n    const data = await loadGTData();\n    console.log(`üìà Loaded data: ${data.total_networks} networks, ${data.total_dexes} DEXes\\n`);\n    \n    // Update configurations\n    await updateChainsConfig(data);\n    await updateDexAllowConfig(data);\n    await generateNetworkSummary(data);\n    \n    console.log('\\n‚úÖ SmallDEX GT integration complete!');\n    console.log('üìã Summary:');\n    console.log(`   ‚Ä¢ Supported networks: ${data.total_networks}`);\n    console.log(`   ‚Ä¢ Supported DEXes: ${data.total_dexes}`);\n    console.log(`   ‚Ä¢ Updated files:`);\n    console.log(`     - netlify/shared/chains.ts`);\n    console.log(`     - netlify/shared/dex-allow.ts`);\n    console.log(`     - data/network-summary.json`);\n    \n  } catch (error) {\n    console.error('‚ùå Fatal error:', error);\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main();\n}\n"
        }
    ]
}