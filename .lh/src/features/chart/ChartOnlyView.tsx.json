{
    "sourceFile": "src/features/chart/ChartOnlyView.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1755352612658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755364214224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,34 +29,43 @@\n   const [showMarkers, setShowMarkers] = useState(false);\n   const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n   const [noTrades, setNoTrades] = useState(false);\n   const [tf, setTf] = useState<Timeframe | null>(null);\n+  const [tfLoading, setTfLoading] = useState(true);\n+  const [tfError, setTfError] = useState(false);\n   const [meta, setMeta] = useState<FetchMeta | null>(null);\n   const loggedRef = useRef(false);\n   const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n \n   useEffect(() => {\n     const cached = getCachedTf(pairId, provider);\n     if (cached) {\n       setTf(cached);\n+      setTfLoading(false);\n       return;\n     }\n     const order: Timeframe[] =\n       provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : ['1m'];\n     (async () => {\n+      setTfLoading(true);\n+      setTfError(false);\n       for (const t of order) {\n         try {\n           const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n           if (res.data.candles.length > 0 || res.data.effectiveTf) {\n             const eff = res.data.effectiveTf || t;\n             setTf(eff);\n             setCachedTf(pairId, provider, eff);\n-            break;\n+            setTfLoading(false);\n+            return;\n           }\n         } catch {\n           /* ignore and try next */\n         }\n       }\n+      // If we get here, no timeframes worked\n+      setTfError(true);\n+      setTfLoading(false);\n     })();\n   }, [pairId, provider, chain, poolAddress]);\n \n   useEffect(() => {\n@@ -93,12 +102,20 @@\n       return next;\n     });\n   }\n \n-  if (!tf) {\n+  if (tfLoading) {\n     return <div>Loadingâ€¦</div>;\n   }\n \n+  if (tfError || !tf) {\n+    return (\n+      <div className=\"limitation-notice\">\n+        Chart data not available for this pair.\n+      </div>\n+    );\n+  }\n+\n   return (\n     <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n       <div style={{ padding: '16px 16px 8px', borderBottom: '1px solid var(--border-subtle)' }}>\n         <label style={{ \n"
                },
                {
                    "date": 1755531727744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import { useState, useEffect, useRef } from 'react';\n import type { Timeframe, Provider } from '../../lib/types';\n import PriceChart from './PriceChart';\n+import TimeframeSelector from './TimeframeSelector';\n import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n import { ohlc } from '../../lib/api';\n import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n import { getTradesCache } from '../../lib/cache';\n@@ -29,8 +30,9 @@\n   const [showMarkers, setShowMarkers] = useState(false);\n   const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n   const [noTrades, setNoTrades] = useState(false);\n   const [tf, setTf] = useState<Timeframe | null>(null);\n+  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n   const [tfLoading, setTfLoading] = useState(true);\n   const [tfError, setTfError] = useState(false);\n   const [meta, setMeta] = useState<FetchMeta | null>(null);\n   const loggedRef = useRef(false);\n@@ -42,33 +44,50 @@\n       setTf(cached);\n       setTfLoading(false);\n       return;\n     }\n+    \n+    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n     const order: Timeframe[] =\n-      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : ['1m'];\n+      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n+      \n     (async () => {\n       setTfLoading(true);\n       setTfError(false);\n-      for (const t of order) {\n+      const availableTfList: Timeframe[] = [];\n+      \n+      // Test all timeframes to see which are available\n+      for (const t of allTimeframes) {\n         try {\n           const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n           if (res.data.candles.length > 0 || res.data.effectiveTf) {\n-            const eff = res.data.effectiveTf || t;\n-            setTf(eff);\n-            setCachedTf(pairId, provider, eff);\n-            setTfLoading(false);\n-            return;\n+            availableTfList.push(res.data.effectiveTf || t);\n           }\n         } catch {\n           /* ignore and try next */\n         }\n       }\n-      // If we get here, no timeframes worked\n-      setTfError(true);\n-      setTfLoading(false);\n+      \n+      setAvailableTfs(availableTfList);\n+      \n+      // Set initial timeframe from available ones\n+      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n+      if (initialTf) {\n+        setTf(initialTf);\n+        setCachedTf(pairId, provider, initialTf);\n+        setTfLoading(false);\n+      } else {\n+        setTfError(true);\n+        setTfLoading(false);\n+      }\n     })();\n   }, [pairId, provider, chain, poolAddress]);\n \n+  const handleTfChange = (newTf: Timeframe) => {\n+    setTf(newTf);\n+    setCachedTf(pairId, provider, newTf);\n+  };\n+\n   useEffect(() => {\n     if (showMarkers) {\n       const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n       setMarkers(m);\n@@ -116,35 +135,33 @@\n   }\n \n   return (\n     <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n-      <div style={{ padding: '16px 16px 8px', borderBottom: '1px solid var(--border-subtle)' }}>\n-        <label style={{ \n-          display: 'flex', \n-          alignItems: 'center', \n-          gap: '8px',\n-          fontSize: '14px',\n-          cursor: 'pointer'\n-        }}>\n-          <input \n-            type=\"checkbox\" \n-            checked={showMarkers} \n-            onChange={handleToggle}\n-            style={{ accentColor: 'var(--accent-telegram)' }}\n-          /> \n-          Trade markers\n-        </label>\n+      <div className=\"chart-controls\">\n+        <div className=\"chart-controls-left\">\n+          <TimeframeSelector \n+            selectedTf={tf}\n+            availableTfs={availableTfs}\n+            onTfChange={handleTfChange}\n+            disabled={tfLoading}\n+          />\n+        </div>\n+        <div className=\"chart-controls-right\">\n+          <label className=\"trade-markers-toggle\">\n+            <input \n+              type=\"checkbox\" \n+              checked={showMarkers} \n+              onChange={handleToggle}\n+            /> \n+            <span>Trade markers</span>\n+          </label>\n+        </div>\n       </div>\n       {showMarkers && noTrades && (\n-        <div style={{ \n-          padding: '8px 16px', \n-          fontSize: '13px', \n-          color: 'var(--text-muted)',\n-          borderBottom: '1px solid var(--border-subtle)'\n-        }}>\n+        <div className=\"no-trades-notice\">\n           <div>No trades available</div>\n           {meta && formatFetchMeta(meta) && (\n-            <div style={{ fontSize: '11px', marginTop: '4px' }}>{formatFetchMeta(meta)}</div>\n+            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n           )}\n         </div>\n       )}\n       <div style={{ flex: 1, position: 'relative' }}>\n"
                },
                {
                    "date": 1755535034352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,207 @@\n+import { useState, useEffect, useRef } from 'react';\n+import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n+import PriceChart from './PriceChart';\n+import TimeframeSelector from './TimeframeSelector';\n+import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n+import { ohlc } from '../../lib/api';\n+import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n+import { getTradesCache } from '../../lib/cache';\n+import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n+\n+type DisplayMode = 'price' | 'marketcap';\n+\n+interface Props {\n+  pairId: string;\n+  chain: string;\n+  poolAddress: string;\n+  provider: Provider;\n+  xDomain: [number, number] | null;\n+  onXDomainChange?: (d: [number, number]) => void;\n+  tokenAddress: string;\n+  tokenDetail?: TokenResponse | null;\n+}\n+\n+export default function ChartOnlyView({\n+  pairId,\n+  chain,\n+  poolAddress,\n+  provider,\n+  xDomain,\n+  onXDomainChange,\n+  tokenAddress,\n+  tokenDetail = null,\n+}: Props) {\n+  const [showMarkers, setShowMarkers] = useState(false);\n+  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n+  const [noTrades, setNoTrades] = useState(false);\n+  const [tf, setTf] = useState<Timeframe | null>(null);\n+  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n+  const [tfLoading, setTfLoading] = useState(true);\n+  const [tfError, setTfError] = useState(false);\n+  const [displayMode, setDisplayMode] = useState<DisplayMode>('price');\n+  const [meta, setMeta] = useState<FetchMeta | null>(null);\n+  const loggedRef = useRef(false);\n+  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n+\n+  useEffect(() => {\n+    const cached = getCachedTf(pairId, provider);\n+    if (cached) {\n+      setTf(cached);\n+      setTfLoading(false);\n+      return;\n+    }\n+    \n+    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n+    const order: Timeframe[] =\n+      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n+      \n+    (async () => {\n+      setTfLoading(true);\n+      setTfError(false);\n+      const availableTfList: Timeframe[] = [];\n+      \n+      // Test all timeframes to see which are available\n+      for (const t of allTimeframes) {\n+        try {\n+          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n+          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n+            availableTfList.push(res.data.effectiveTf || t);\n+          }\n+        } catch {\n+          /* ignore and try next */\n+        }\n+      }\n+      \n+      setAvailableTfs(availableTfList);\n+      \n+      // Set initial timeframe from available ones\n+      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n+      if (initialTf) {\n+        setTf(initialTf);\n+        setCachedTf(pairId, provider, initialTf);\n+        setTfLoading(false);\n+      } else {\n+        setTfError(true);\n+        setTfLoading(false);\n+      }\n+    })();\n+  }, [pairId, provider, chain, poolAddress]);\n+\n+  const handleTfChange = (newTf: Timeframe) => {\n+    setTf(newTf);\n+    setCachedTf(pairId, provider, newTf);\n+  };\n+\n+  useEffect(() => {\n+    if (showMarkers) {\n+      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n+      setMarkers(m);\n+      setNoTrades(m.length === 0);\n+      const parts: string[] = [];\n+      if (chain) parts.push(chain);\n+      parts.push(pairId);\n+      if (poolAddress) parts.push(poolAddress);\n+      parts.push(tokenAddress);\n+      const key = parts.join(':');\n+      const cached = getTradesCache(key);\n+      setMeta(cached?.meta || null);\n+    }\n+  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n+\n+  useEffect(() => {\n+    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n+      console.log('no-trades meta', meta);\n+      loggedRef.current = true;\n+    }\n+  }, [showMarkers, noTrades, meta]);\n+\n+  function handleToggle() {\n+    setShowMarkers((v) => {\n+      const next = !v;\n+      if (next) {\n+        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n+      } else {\n+        setMarkers([]);\n+      }\n+      return next;\n+    });\n+  }\n+\n+  if (tfLoading) {\n+    return <div>Loadingâ€¦</div>;\n+  }\n+\n+  if (tfError || !tf) {\n+    return (\n+      <div className=\"limitation-notice\">\n+        Chart data not available for this pair.\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n+      <div className=\"chart-controls\">\n+        <div className=\"chart-controls-left\">\n+          <TimeframeSelector \n+            selectedTf={tf}\n+            availableTfs={availableTfs}\n+            onTfChange={handleTfChange}\n+            disabled={tfLoading}\n+          />\n+          <div className=\"chart-display-mode\">\n+            <button\n+              className={`chart-mode-button ${displayMode === 'price' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('price')}\n+              type=\"button\"\n+            >\n+              Price\n+            </button>\n+            <button\n+              className={`chart-mode-button ${displayMode === 'marketcap' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('marketcap')}\n+              disabled={!tokenDetail?.info}\n+              type=\"button\"\n+            >\n+              Market Cap\n+            </button>\n+          </div>\n+        </div>\n+        <div className=\"chart-controls-right\">\n+          <label className=\"trade-markers-toggle\">\n+            <input \n+              type=\"checkbox\" \n+              checked={showMarkers} \n+              onChange={handleToggle}\n+            /> \n+            <span>Trades</span>\n+          </label>\n+        </div>\n+      </div>\n+      {showMarkers && noTrades && (\n+        <div className=\"no-trades-notice\">\n+          <div>No trades available</div>\n+          {meta && formatFetchMeta(meta) && (\n+            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n+          )}\n+        </div>\n+      )}\n+      <div style={{ flex: 1, position: 'relative' }}>\n+        <PriceChart\n+          pairId={pairId}\n+          tf={tf}\n+          xDomain={xDomain}\n+          onXDomainChange={onXDomainChange}\n+          markers={showMarkers ? markers : []}\n+          chain={chain}\n+          poolAddress={poolAddress}\n+          tokenAddress={tokenAddress}\n+          tokenDetail={tokenDetail}\n+          displayMode={displayMode}\n+          onDisplayModeChange={setDisplayMode}\n+        />\n+      </div>\n+    </div>\n+  );\n+}\n+\n"
                },
                {
                    "date": 1755542625821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+import { useState, useEffect, useRef } from 'react';\n+import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n+import PriceChart from './PriceChart';\n+import TimeframeSelector from './TimeframeSelector';\n+import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n+import { ohlc } from '../../lib/api';\n+import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n+import { getTradesCache } from '../../lib/cache';\n+import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n+\n+type DisplayMode = 'price' | 'marketcap';\n+\n+interface Props {\n+  pairId: string;\n+  chain: string;\n+  poolAddress: string;\n+  provider: Provider;\n+  xDomain: [number, number] | null;\n+  onXDomainChange?: (d: [number, number]) => void;\n+  tokenAddress: string;\n+  tokenDetail?: TokenResponse | null;\n+}\n+\n+export default function ChartOnlyView({\n+  pairId,\n+  chain,\n+  poolAddress,\n+  provider,\n+  xDomain,\n+  onXDomainChange,\n+  tokenAddress,\n+  tokenDetail = null,\n+}: Props) {\n+  const [showMarkers, setShowMarkers] = useState(false);\n+  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n+  const [noTrades, setNoTrades] = useState(false);\n+  const [tf, setTf] = useState<Timeframe | null>(null);\n+  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n+  const [tfLoading, setTfLoading] = useState(true);\n+  const [tfError, setTfError] = useState(false);\n+  const [displayMode, setDisplayMode] = useState<DisplayMode>('price');\n+  const [meta, setMeta] = useState<FetchMeta | null>(null);\n+  const loggedRef = useRef(false);\n+  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n+\n+  useEffect(() => {\n+    const cached = getCachedTf(pairId, provider);\n+    if (cached) {\n+      setTf(cached);\n+      setTfLoading(false);\n+      return;\n+    }\n+    \n+    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n+    const order: Timeframe[] =\n+      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n+      \n+    (async () => {\n+      setTfLoading(true);\n+      setTfError(false);\n+      const availableTfList: Timeframe[] = [];\n+      \n+      // Test all timeframes to see which are available\n+      for (const t of allTimeframes) {\n+        try {\n+          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n+          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n+            availableTfList.push(res.data.effectiveTf || t);\n+          }\n+        } catch {\n+          /* ignore and try next */\n+        }\n+      }\n+      \n+      setAvailableTfs(availableTfList);\n+      \n+      // Set initial timeframe from available ones\n+      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n+      if (initialTf) {\n+        setTf(initialTf);\n+        setCachedTf(pairId, provider, initialTf);\n+        setTfLoading(false);\n+      } else {\n+        setTfError(true);\n+        setTfLoading(false);\n+      }\n+    })();\n+  }, [pairId, provider, chain, poolAddress]);\n+\n+  const handleTfChange = (newTf: Timeframe) => {\n+    setTf(newTf);\n+    setCachedTf(pairId, provider, newTf);\n+  };\n+\n+  useEffect(() => {\n+    if (showMarkers) {\n+      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n+      setMarkers(m);\n+      setNoTrades(m.length === 0);\n+      const parts: string[] = [];\n+      if (chain) parts.push(chain);\n+      parts.push(pairId);\n+      if (poolAddress) parts.push(poolAddress);\n+      parts.push(tokenAddress);\n+      const key = parts.join(':');\n+      const cached = getTradesCache(key);\n+      setMeta(cached?.meta || null);\n+    }\n+  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n+\n+  useEffect(() => {\n+    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n+      console.log('no-trades meta', meta);\n+      loggedRef.current = true;\n+    }\n+  }, [showMarkers, noTrades, meta]);\n+\n+  function handleToggle() {\n+    setShowMarkers((v) => {\n+      const next = !v;\n+      if (next) {\n+        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n+      } else {\n+        setMarkers([]);\n+      }\n+      return next;\n+    });\n+  }\n+\n+  if (tfLoading) {\n+    return <div>Loadingâ€¦</div>;\n+  }\n+\n+  if (tfError || !tf) {\n+    return (\n+      <div className=\"limitation-notice\">\n+        Chart data not available for this pair.\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n+      <div className=\"chart-controls\">\n+        <div className=\"chart-controls-left\">\n+          <TimeframeSelector \n+            selectedTf={tf}\n+            availableTfs={availableTfs}\n+            onTfChange={handleTfChange}\n+            disabled={tfLoading}\n+          />\n+          {/* TODO: Uncomment when totalSupply data is available\n+          <div className=\"chart-display-mode\">\n+            <button\n+              className={`chart-mode-button ${displayMode === 'price' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('price')}\n+              type=\"button\"\n+            >\n+              Price\n+            </button>\n+            <button\n+              className={`chart-mode-button ${displayMode === 'marketcap' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('marketcap')}\n+              disabled={!tokenDetail?.info}\n+              type=\"button\"\n+            >\n+              Market Cap\n+            </button>\n+          </div>\n+          */}\n+          <label className=\"trade-markers-toggle\">\n+            <input \n+              type=\"checkbox\" \n+              checked={showMarkers} \n+              onChange={handleToggle}\n+            /> \n+            <span>Trades</span>\n+          </label>\n+        </div>\n+        <div className=\"chart-controls-right\">\n+          {/* Space for future controls */}\n+        </div>\n+      </div>\n+      {showMarkers && noTrades && (\n+        <div className=\"no-trades-notice\">\n+          <div>No trades available</div>\n+          {meta && formatFetchMeta(meta) && (\n+            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n+          )}\n+        </div>\n+      )}\n+      <div style={{ flex: 1, position: 'relative' }}>\n+        <PriceChart\n+          pairId={pairId}\n+          tf={tf}\n+          xDomain={xDomain}\n+          onXDomainChange={onXDomainChange}\n+          markers={showMarkers ? markers : []}\n+          chain={chain}\n+          poolAddress={poolAddress}\n+          tokenAddress={tokenAddress}\n+          tokenDetail={tokenDetail}\n+          displayMode={displayMode}\n+          onDisplayModeChange={setDisplayMode}\n+        />\n+      </div>\n+      \n+      {/* Chart info badges moved below */}\n+      <div className=\"chart-badges\" style={{ \n+        display: 'flex', \n+        justifyContent: 'space-between', \n+        alignItems: 'center',\n+        padding: 'var(--space-2) var(--space-4)',\n+        background: 'var(--bg-elev)',\n+        borderTop: '1px solid var(--border)',\n+        fontSize: '11px',\n+        color: 'var(--text-muted)',\n+      }}>\n+        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n+          {tf && (\n+            <span>UTC â€¢ {tf}</span>\n+          )}\n+          {/* Add provider info if available */}\n+        </div>\n+        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n+          {meta && formatFetchMeta(meta) && (\n+            <span>{formatFetchMeta(meta)}</span>\n+          )}\n+        </div>\n+      </div>\n+    </div>\n+  );\n+}\n+\n"
                },
                {
                    "date": 1755714818842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import { useState, useEffect, useRef } from 'react';\n import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n+import type { ProcessedSecurityData } from '../../lib/goplus-types';\n import PriceChart from './PriceChart';\n import TimeframeSelector from './TimeframeSelector';\n import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n import { ohlc } from '../../lib/api';\n@@ -18,8 +19,9 @@\n   xDomain: [number, number] | null;\n   onXDomainChange?: (d: [number, number]) => void;\n   tokenAddress: string;\n   tokenDetail?: TokenResponse | null;\n+  securityData?: ProcessedSecurityData | null;\n }\n \n export default function ChartOnlyView({\n   pairId,\n@@ -29,8 +31,9 @@\n   xDomain,\n   onXDomainChange,\n   tokenAddress,\n   tokenDetail = null,\n+  securityData = null,\n }: Props) {\n   const [showMarkers, setShowMarkers] = useState(false);\n   const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n   const [noTrades, setNoTrades] = useState(false);\n@@ -231,393 +234,4 @@\n     </div>\n   );\n }\n \n-import { useState, useEffect, useRef } from 'react';\n-import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n-import PriceChart from './PriceChart';\n-import TimeframeSelector from './TimeframeSelector';\n-import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n-import { ohlc } from '../../lib/api';\n-import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n-import { getTradesCache } from '../../lib/cache';\n-import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n-\n-type DisplayMode = 'price' | 'marketcap';\n-\n-interface Props {\n-  pairId: string;\n-  chain: string;\n-  poolAddress: string;\n-  provider: Provider;\n-  xDomain: [number, number] | null;\n-  onXDomainChange?: (d: [number, number]) => void;\n-  tokenAddress: string;\n-  tokenDetail?: TokenResponse | null;\n-}\n-\n-export default function ChartOnlyView({\n-  pairId,\n-  chain,\n-  poolAddress,\n-  provider,\n-  xDomain,\n-  onXDomainChange,\n-  tokenAddress,\n-  tokenDetail = null,\n-}: Props) {\n-  const [showMarkers, setShowMarkers] = useState(false);\n-  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n-  const [noTrades, setNoTrades] = useState(false);\n-  const [tf, setTf] = useState<Timeframe | null>(null);\n-  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n-  const [tfLoading, setTfLoading] = useState(true);\n-  const [tfError, setTfError] = useState(false);\n-  const [displayMode, setDisplayMode] = useState<DisplayMode>('price');\n-  const [meta, setMeta] = useState<FetchMeta | null>(null);\n-  const loggedRef = useRef(false);\n-  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n-\n-  useEffect(() => {\n-    const cached = getCachedTf(pairId, provider);\n-    if (cached) {\n-      setTf(cached);\n-      setTfLoading(false);\n-      return;\n-    }\n-    \n-    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n-    const order: Timeframe[] =\n-      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n-      \n-    (async () => {\n-      setTfLoading(true);\n-      setTfError(false);\n-      const availableTfList: Timeframe[] = [];\n-      \n-      // Test all timeframes to see which are available\n-      for (const t of allTimeframes) {\n-        try {\n-          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n-          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n-            availableTfList.push(res.data.effectiveTf || t);\n-          }\n-        } catch {\n-          /* ignore and try next */\n-        }\n-      }\n-      \n-      setAvailableTfs(availableTfList);\n-      \n-      // Set initial timeframe from available ones\n-      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n-      if (initialTf) {\n-        setTf(initialTf);\n-        setCachedTf(pairId, provider, initialTf);\n-        setTfLoading(false);\n-      } else {\n-        setTfError(true);\n-        setTfLoading(false);\n-      }\n-    })();\n-  }, [pairId, provider, chain, poolAddress]);\n-\n-  const handleTfChange = (newTf: Timeframe) => {\n-    setTf(newTf);\n-    setCachedTf(pairId, provider, newTf);\n-  };\n-\n-  useEffect(() => {\n-    if (showMarkers) {\n-      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n-      setMarkers(m);\n-      setNoTrades(m.length === 0);\n-      const parts: string[] = [];\n-      if (chain) parts.push(chain);\n-      parts.push(pairId);\n-      if (poolAddress) parts.push(poolAddress);\n-      parts.push(tokenAddress);\n-      const key = parts.join(':');\n-      const cached = getTradesCache(key);\n-      setMeta(cached?.meta || null);\n-    }\n-  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n-\n-  useEffect(() => {\n-    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n-      console.log('no-trades meta', meta);\n-      loggedRef.current = true;\n-    }\n-  }, [showMarkers, noTrades, meta]);\n-\n-  function handleToggle() {\n-    setShowMarkers((v) => {\n-      const next = !v;\n-      if (next) {\n-        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n-      } else {\n-        setMarkers([]);\n-      }\n-      return next;\n-    });\n-  }\n-\n-  if (tfLoading) {\n-    return <div>Loadingâ€¦</div>;\n-  }\n-\n-  if (tfError || !tf) {\n-    return (\n-      <div className=\"limitation-notice\">\n-        Chart data not available for this pair.\n-      </div>\n-    );\n-  }\n-\n-  return (\n-    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n-      <div className=\"chart-controls\">\n-        <div className=\"chart-controls-left\">\n-          <TimeframeSelector \n-            selectedTf={tf}\n-            availableTfs={availableTfs}\n-            onTfChange={handleTfChange}\n-            disabled={tfLoading}\n-          />\n-          <div className=\"chart-display-mode\">\n-            <button\n-              className={`chart-mode-button ${displayMode === 'price' ? 'selected' : ''}`}\n-              onClick={() => setDisplayMode('price')}\n-              type=\"button\"\n-            >\n-              Price\n-            </button>\n-            <button\n-              className={`chart-mode-button ${displayMode === 'marketcap' ? 'selected' : ''}`}\n-              onClick={() => setDisplayMode('marketcap')}\n-              disabled={!tokenDetail?.info}\n-              type=\"button\"\n-            >\n-              Market Cap\n-            </button>\n-          </div>\n-        </div>\n-        <div className=\"chart-controls-right\">\n-          <label className=\"trade-markers-toggle\">\n-            <input \n-              type=\"checkbox\" \n-              checked={showMarkers} \n-              onChange={handleToggle}\n-            /> \n-            <span>Trades</span>\n-          </label>\n-        </div>\n-      </div>\n-      {showMarkers && noTrades && (\n-        <div className=\"no-trades-notice\">\n-          <div>No trades available</div>\n-          {meta && formatFetchMeta(meta) && (\n-            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n-          )}\n-        </div>\n-      )}\n-      <div style={{ flex: 1, position: 'relative' }}>\n-        <PriceChart\n-          pairId={pairId}\n-          tf={tf}\n-          xDomain={xDomain}\n-          onXDomainChange={onXDomainChange}\n-          markers={showMarkers ? markers : []}\n-          chain={chain}\n-          poolAddress={poolAddress}\n-          tokenAddress={tokenAddress}\n-          tokenDetail={tokenDetail}\n-          displayMode={displayMode}\n-          onDisplayModeChange={setDisplayMode}\n-        />\n-      </div>\n-    </div>\n-  );\n-}\n-\n-import { useState, useEffect, useRef } from 'react';\n-import type { Timeframe, Provider } from '../../lib/types';\n-import PriceChart from './PriceChart';\n-import TimeframeSelector from './TimeframeSelector';\n-import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n-import { ohlc } from '../../lib/api';\n-import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n-import { getTradesCache } from '../../lib/cache';\n-import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n-\n-interface Props {\n-  pairId: string;\n-  chain: string;\n-  poolAddress: string;\n-  provider: Provider;\n-  xDomain: [number, number] | null;\n-  onXDomainChange?: (d: [number, number]) => void;\n-  tokenAddress: string;\n-}\n-\n-export default function ChartOnlyView({\n-  pairId,\n-  chain,\n-  poolAddress,\n-  provider,\n-  xDomain,\n-  onXDomainChange,\n-  tokenAddress,\n-}: Props) {\n-  const [showMarkers, setShowMarkers] = useState(false);\n-  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n-  const [noTrades, setNoTrades] = useState(false);\n-  const [tf, setTf] = useState<Timeframe | null>(null);\n-  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n-  const [tfLoading, setTfLoading] = useState(true);\n-  const [tfError, setTfError] = useState(false);\n-  const [meta, setMeta] = useState<FetchMeta | null>(null);\n-  const loggedRef = useRef(false);\n-  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n-\n-  useEffect(() => {\n-    const cached = getCachedTf(pairId, provider);\n-    if (cached) {\n-      setTf(cached);\n-      setTfLoading(false);\n-      return;\n-    }\n-    \n-    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n-    const order: Timeframe[] =\n-      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n-      \n-    (async () => {\n-      setTfLoading(true);\n-      setTfError(false);\n-      const availableTfList: Timeframe[] = [];\n-      \n-      // Test all timeframes to see which are available\n-      for (const t of allTimeframes) {\n-        try {\n-          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n-          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n-            availableTfList.push(res.data.effectiveTf || t);\n-          }\n-        } catch {\n-          /* ignore and try next */\n-        }\n-      }\n-      \n-      setAvailableTfs(availableTfList);\n-      \n-      // Set initial timeframe from available ones\n-      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n-      if (initialTf) {\n-        setTf(initialTf);\n-        setCachedTf(pairId, provider, initialTf);\n-        setTfLoading(false);\n-      } else {\n-        setTfError(true);\n-        setTfLoading(false);\n-      }\n-    })();\n-  }, [pairId, provider, chain, poolAddress]);\n-\n-  const handleTfChange = (newTf: Timeframe) => {\n-    setTf(newTf);\n-    setCachedTf(pairId, provider, newTf);\n-  };\n-\n-  useEffect(() => {\n-    if (showMarkers) {\n-      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n-      setMarkers(m);\n-      setNoTrades(m.length === 0);\n-      const parts: string[] = [];\n-      if (chain) parts.push(chain);\n-      parts.push(pairId);\n-      if (poolAddress) parts.push(poolAddress);\n-      parts.push(tokenAddress);\n-      const key = parts.join(':');\n-      const cached = getTradesCache(key);\n-      setMeta(cached?.meta || null);\n-    }\n-  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n-\n-  useEffect(() => {\n-    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n-      console.log('no-trades meta', meta);\n-      loggedRef.current = true;\n-    }\n-  }, [showMarkers, noTrades, meta]);\n-\n-  function handleToggle() {\n-    setShowMarkers((v) => {\n-      const next = !v;\n-      if (next) {\n-        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n-      } else {\n-        setMarkers([]);\n-      }\n-      return next;\n-    });\n-  }\n-\n-  if (tfLoading) {\n-    return <div>Loadingâ€¦</div>;\n-  }\n-\n-  if (tfError || !tf) {\n-    return (\n-      <div className=\"limitation-notice\">\n-        Chart data not available for this pair.\n-      </div>\n-    );\n-  }\n-\n-  return (\n-    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n-      <div className=\"chart-controls\">\n-        <div className=\"chart-controls-left\">\n-          <TimeframeSelector \n-            selectedTf={tf}\n-            availableTfs={availableTfs}\n-            onTfChange={handleTfChange}\n-            disabled={tfLoading}\n-          />\n-        </div>\n-        <div className=\"chart-controls-right\">\n-          <label className=\"trade-markers-toggle\">\n-            <input \n-              type=\"checkbox\" \n-              checked={showMarkers} \n-              onChange={handleToggle}\n-            /> \n-            <span>Trade markers</span>\n-          </label>\n-        </div>\n-      </div>\n-      {showMarkers && noTrades && (\n-        <div className=\"no-trades-notice\">\n-          <div>No trades available</div>\n-          {meta && formatFetchMeta(meta) && (\n-            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n-          )}\n-        </div>\n-      )}\n-      <div style={{ flex: 1, position: 'relative' }}>\n-        <PriceChart\n-          pairId={pairId}\n-          tf={tf}\n-          xDomain={xDomain}\n-          onXDomainChange={onXDomainChange}\n-          markers={showMarkers ? markers : []}\n-          chain={chain}\n-          poolAddress={poolAddress}\n-          tokenAddress={tokenAddress}\n-        />\n-      </div>\n-    </div>\n-  );\n-}\n-\n"
                },
                {
                    "date": 1755799100870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,305 @@\n+import { useState, useEffect, useRef } from 'react';\n+import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n+import type { ProcessedSecurityData } from '../../lib/goplus-types';\n+import PriceChart from './PriceChart';\n+import TimeframeSelector from './TimeframeSelector';\n+import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n+import { ohlc } from '../../lib/api';\n+import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n+import { getTradesCache } from '../../lib/cache';\n+import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n+\n+type DisplayMode = 'price' | 'marketcap';\n+\n+interface Props {\n+  pairId: string;\n+  chain: string;\n+  poolAddress: string;\n+  provider: Provider;\n+  xDomain: [number, number] | null;\n+  onXDomainChange?: (d: [number, number]) => void;\n+  tokenAddress: string;\n+  tokenDetail?: TokenResponse | null;\n+  securityData?: ProcessedSecurityData | null;\n+}\n+\n+export default function ChartOnlyView({\n+  pairId,\n+  chain,\n+  poolAddress,\n+  provider,\n+  xDomain,\n+  onXDomainChange,\n+  tokenAddress,\n+  tokenDetail = null,\n+  securityData = null,\n+}: Props) {\n+  const [showMarkers, setShowMarkers] = useState(false);\n+  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n+  const [noTrades, setNoTrades] = useState(false);\n+  const [tf, setTf] = useState<Timeframe | null>(null);\n+  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n+  const [tfLoading, setTfLoading] = useState(true);\n+  const [tfError, setTfError] = useState(false);\n+  const [displayMode, setDisplayMode] = useState<DisplayMode>('price');\n+  const [meta, setMeta] = useState<FetchMeta | null>(null);\n+  // New chart configuration states\n+  const [chartType, setChartType] = useState<'candlestick' | 'line'>('candlestick');\n+  const [showVolume, setShowVolume] = useState(true);\n+  const [crosshairMode, setCrosshairMode] = useState<'normal' | 'magnet'>('normal');\n+  const loggedRef = useRef(false);\n+  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n+\n+  useEffect(() => {\n+    const cached = getCachedTf(pairId, provider);\n+    if (cached) {\n+      setTf(cached);\n+      setTfLoading(false);\n+      return;\n+    }\n+    \n+    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n+    const order: Timeframe[] =\n+      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n+      \n+    (async () => {\n+      setTfLoading(true);\n+      setTfError(false);\n+      const availableTfList: Timeframe[] = [];\n+      \n+      // Test all timeframes to see which are available\n+      for (const t of allTimeframes) {\n+        try {\n+          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n+          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n+            availableTfList.push(res.data.effectiveTf || t);\n+          }\n+        } catch {\n+          /* ignore and try next */\n+        }\n+      }\n+      \n+      setAvailableTfs(availableTfList);\n+      \n+      // Set initial timeframe from available ones\n+      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n+      if (initialTf) {\n+        setTf(initialTf);\n+        setCachedTf(pairId, provider, initialTf);\n+        setTfLoading(false);\n+      } else {\n+        setTfError(true);\n+        setTfLoading(false);\n+      }\n+    })();\n+  }, [pairId, provider, chain, poolAddress]);\n+\n+  const handleTfChange = (newTf: Timeframe) => {\n+    setTf(newTf);\n+    setCachedTf(pairId, provider, newTf);\n+  };\n+\n+  useEffect(() => {\n+    if (showMarkers) {\n+      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n+      setMarkers(m);\n+      setNoTrades(m.length === 0);\n+      const parts: string[] = [];\n+      if (chain) parts.push(chain);\n+      parts.push(pairId);\n+      if (poolAddress) parts.push(poolAddress);\n+      parts.push(tokenAddress);\n+      const key = parts.join(':');\n+      const cached = getTradesCache(key);\n+      setMeta(cached?.meta || null);\n+    }\n+  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n+\n+  useEffect(() => {\n+    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n+      console.log('no-trades meta', meta);\n+      loggedRef.current = true;\n+    }\n+  }, [showMarkers, noTrades, meta]);\n+\n+  function handleToggle() {\n+    setShowMarkers((v) => {\n+      const next = !v;\n+      if (next) {\n+        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n+      } else {\n+        setMarkers([]);\n+      }\n+      return next;\n+    });\n+  }\n+\n+  if (tfLoading) {\n+    return <div>Loadingâ€¦</div>;\n+  }\n+\n+  if (tfError || !tf) {\n+    return (\n+      <div className=\"limitation-notice\">\n+        Chart data not available for this pair.\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n+      <div className=\"chart-controls\">\n+        <div className=\"chart-controls-left\">\n+          <TimeframeSelector \n+            selectedTf={tf}\n+            availableTfs={availableTfs}\n+            onTfChange={handleTfChange}\n+            disabled={tfLoading}\n+          />\n+          {/* TODO: Uncomment when totalSupply data is available\n+          <div className=\"chart-display-mode\">\n+            <button\n+              className={`chart-mode-button ${displayMode === 'price' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('price')}\n+              type=\"button\"\n+            >\n+              Price\n+            </button>\n+            <button\n+              className={`chart-mode-button ${displayMode === 'marketcap' ? 'selected' : ''}`}\n+              onClick={() => setDisplayMode('marketcap')}\n+              disabled={!tokenDetail?.info}\n+              type=\"button\"\n+            >\n+              Market Cap\n+            </button>\n+          </div>\n+          */}\n+          <label className=\"trade-markers-toggle\">\n+            <input \n+              type=\"checkbox\" \n+              checked={showMarkers} \n+              onChange={handleToggle}\n+            /> \n+            <span>Trades</span>\n+          </label>\n+          \n+          {/* Chart Type Toggle */}\n+          <div className=\"chart-type-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>\n+            <button\n+              className={`chart-type-button ${chartType === 'candlestick' ? 'selected' : ''}`}\n+              onClick={() => setChartType('candlestick')}\n+              type=\"button\"\n+              style={{\n+                padding: '4px 8px',\n+                fontSize: '11px',\n+                border: '1px solid var(--border)',\n+                borderRadius: '4px',\n+                background: chartType === 'candlestick' ? 'var(--accent-lime)' : 'transparent',\n+                color: chartType === 'candlestick' ? 'var(--bg)' : 'var(--text)',\n+                cursor: 'pointer'\n+              }}\n+            >\n+              Candles\n+            </button>\n+            <button\n+              className={`chart-type-button ${chartType === 'line' ? 'selected' : ''}`}\n+              onClick={() => setChartType('line')}\n+              type=\"button\"\n+              style={{\n+                padding: '4px 8px',\n+                fontSize: '11px',\n+                border: '1px solid var(--border)',\n+                borderRadius: '4px',\n+                background: chartType === 'line' ? 'var(--accent-lime)' : 'transparent',\n+                color: chartType === 'line' ? 'var(--bg)' : 'var(--text)',\n+                cursor: 'pointer'\n+              }}\n+            >\n+              Line\n+            </button>\n+          </div>\n+          \n+          {/* Volume Toggle */}\n+          <label className=\"volume-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px' }}>\n+            <input \n+              type=\"checkbox\" \n+              checked={showVolume} \n+              onChange={(e) => setShowVolume(e.target.checked)}\n+            /> \n+            <span>Volume</span>\n+          </label>\n+        </div>\n+        <div className=\"chart-controls-right\">\n+          {/* Crosshair Mode Toggle */}\n+          <button\n+            onClick={() => setCrosshairMode(prev => prev === 'normal' ? 'magnet' : 'normal')}\n+            type=\"button\"\n+            style={{\n+              padding: '4px 8px',\n+              fontSize: '10px',\n+              border: '1px solid var(--border)',\n+              borderRadius: '4px',\n+              background: crosshairMode === 'magnet' ? 'var(--accent-telegram)' : 'transparent',\n+              color: crosshairMode === 'magnet' ? 'var(--bg)' : 'var(--text-muted)',\n+              cursor: 'pointer'\n+            }}\n+            title={`Crosshair: ${crosshairMode}`}\n+          />\n+            {crosshairMode === 'magnet' ? 'ðŸ§²' : '+'}\n+        </div>\n+      </div>\n+      {showMarkers && noTrades && (\n+        <div className=\"no-trades-notice\">\n+          <div>No trades available</div>\n+          {meta && formatFetchMeta(meta) && (\n+            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n+          )}\n+        </div>\n+      )}\n+      <div style={{ flex: 1, position: 'relative' }}>\n+        <PriceChart\n+          pairId={pairId}\n+          tf={tf}\n+          xDomain={xDomain}\n+          onXDomainChange={onXDomainChange}\n+          markers={showMarkers ? markers : []}\n+          chain={chain}\n+          poolAddress={poolAddress}\n+          tokenAddress={tokenAddress}\n+          tokenDetail={tokenDetail}\n+          displayMode={displayMode}\n+          onDisplayModeChange={setDisplayMode}\n+          chartType={chartType}\n+          showVolume={showVolume}\n+          crosshairMode={crosshairMode}\n+        />\n+      </div>\n+      \n+      {/* Chart info badges moved below */}\n+      <div className=\"chart-badges\" style={{ \n+        display: 'flex', \n+        justifyContent: 'space-between', \n+        alignItems: 'center',\n+        padding: 'var(--space-2) var(--space-4)',\n+        background: 'var(--bg-elev)',\n+        borderTop: '1px solid var(--border)',\n+        fontSize: '11px',\n+        color: 'var(--text-muted)',\n+      }}>\n+        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n+          {tf && (\n+            <span>UTC â€¢ {tf}</span>\n+          )}\n+          {/* Add provider info if available */}\n+        </div>\n+        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n+          {meta && formatFetchMeta(meta) && (\n+            <span>{formatFetchMeta(meta)}</span>\n+          )}\n+        </div>\n+      </div>\n+    </div>\n+  );\n+}\n+\n"
                },
                {
                    "date": 1755799181561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,241 +302,4 @@\n     </div>\n   );\n }\n \n-import { useState, useEffect, useRef } from 'react';\n-import type { Timeframe, Provider, TokenResponse } from '../../lib/types';\n-import type { ProcessedSecurityData } from '../../lib/goplus-types';\n-import PriceChart from './PriceChart';\n-import TimeframeSelector from './TimeframeSelector';\n-import { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\n-import { ohlc } from '../../lib/api';\n-import { getCachedTf, setCachedTf } from '../../lib/tf-cache';\n-import { getTradesCache } from '../../lib/cache';\n-import { formatFetchMeta, type FetchMeta } from '../../lib/format';\n-\n-type DisplayMode = 'price' | 'marketcap';\n-\n-interface Props {\n-  pairId: string;\n-  chain: string;\n-  poolAddress: string;\n-  provider: Provider;\n-  xDomain: [number, number] | null;\n-  onXDomainChange?: (d: [number, number]) => void;\n-  tokenAddress: string;\n-  tokenDetail?: TokenResponse | null;\n-  securityData?: ProcessedSecurityData | null;\n-}\n-\n-export default function ChartOnlyView({\n-  pairId,\n-  chain,\n-  poolAddress,\n-  provider,\n-  xDomain,\n-  onXDomainChange,\n-  tokenAddress,\n-  tokenDetail = null,\n-  securityData = null,\n-}: Props) {\n-  const [showMarkers, setShowMarkers] = useState(false);\n-  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n-  const [noTrades, setNoTrades] = useState(false);\n-  const [tf, setTf] = useState<Timeframe | null>(null);\n-  const [availableTfs, setAvailableTfs] = useState<Timeframe[]>([]);\n-  const [tfLoading, setTfLoading] = useState(true);\n-  const [tfError, setTfError] = useState(false);\n-  const [displayMode, setDisplayMode] = useState<DisplayMode>('price');\n-  const [meta, setMeta] = useState<FetchMeta | null>(null);\n-  const loggedRef = useRef(false);\n-  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n-\n-  useEffect(() => {\n-    const cached = getCachedTf(pairId, provider);\n-    if (cached) {\n-      setTf(cached);\n-      setTfLoading(false);\n-      return;\n-    }\n-    \n-    const allTimeframes: Timeframe[] = ['1m', '5m', '15m', '1h', '4h', '1d'];\n-    const order: Timeframe[] =\n-      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : allTimeframes;\n-      \n-    (async () => {\n-      setTfLoading(true);\n-      setTfError(false);\n-      const availableTfList: Timeframe[] = [];\n-      \n-      // Test all timeframes to see which are available\n-      for (const t of allTimeframes) {\n-        try {\n-          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n-          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n-            availableTfList.push(res.data.effectiveTf || t);\n-          }\n-        } catch {\n-          /* ignore and try next */\n-        }\n-      }\n-      \n-      setAvailableTfs(availableTfList);\n-      \n-      // Set initial timeframe from available ones\n-      const initialTf = order.find(t => availableTfList.includes(t)) || availableTfList[0];\n-      if (initialTf) {\n-        setTf(initialTf);\n-        setCachedTf(pairId, provider, initialTf);\n-        setTfLoading(false);\n-      } else {\n-        setTfError(true);\n-        setTfLoading(false);\n-      }\n-    })();\n-  }, [pairId, provider, chain, poolAddress]);\n-\n-  const handleTfChange = (newTf: Timeframe) => {\n-    setTf(newTf);\n-    setCachedTf(pairId, provider, newTf);\n-  };\n-\n-  useEffect(() => {\n-    if (showMarkers) {\n-      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n-      setMarkers(m);\n-      setNoTrades(m.length === 0);\n-      const parts: string[] = [];\n-      if (chain) parts.push(chain);\n-      parts.push(pairId);\n-      if (poolAddress) parts.push(poolAddress);\n-      parts.push(tokenAddress);\n-      const key = parts.join(':');\n-      const cached = getTradesCache(key);\n-      setMeta(cached?.meta || null);\n-    }\n-  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n-\n-  useEffect(() => {\n-    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n-      console.log('no-trades meta', meta);\n-      loggedRef.current = true;\n-    }\n-  }, [showMarkers, noTrades, meta]);\n-\n-  function handleToggle() {\n-    setShowMarkers((v) => {\n-      const next = !v;\n-      if (next) {\n-        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n-      } else {\n-        setMarkers([]);\n-      }\n-      return next;\n-    });\n-  }\n-\n-  if (tfLoading) {\n-    return <div>Loadingâ€¦</div>;\n-  }\n-\n-  if (tfError || !tf) {\n-    return (\n-      <div className=\"limitation-notice\">\n-        Chart data not available for this pair.\n-      </div>\n-    );\n-  }\n-\n-  return (\n-    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n-      <div className=\"chart-controls\">\n-        <div className=\"chart-controls-left\">\n-          <TimeframeSelector \n-            selectedTf={tf}\n-            availableTfs={availableTfs}\n-            onTfChange={handleTfChange}\n-            disabled={tfLoading}\n-          />\n-          {/* TODO: Uncomment when totalSupply data is available\n-          <div className=\"chart-display-mode\">\n-            <button\n-              className={`chart-mode-button ${displayMode === 'price' ? 'selected' : ''}`}\n-              onClick={() => setDisplayMode('price')}\n-              type=\"button\"\n-            >\n-              Price\n-            </button>\n-            <button\n-              className={`chart-mode-button ${displayMode === 'marketcap' ? 'selected' : ''}`}\n-              onClick={() => setDisplayMode('marketcap')}\n-              disabled={!tokenDetail?.info}\n-              type=\"button\"\n-            >\n-              Market Cap\n-            </button>\n-          </div>\n-          */}\n-          <label className=\"trade-markers-toggle\">\n-            <input \n-              type=\"checkbox\" \n-              checked={showMarkers} \n-              onChange={handleToggle}\n-            /> \n-            <span>Trades</span>\n-          </label>\n-        </div>\n-        <div className=\"chart-controls-right\">\n-          {/* Space for future controls */}\n-        </div>\n-      </div>\n-      {showMarkers && noTrades && (\n-        <div className=\"no-trades-notice\">\n-          <div>No trades available</div>\n-          {meta && formatFetchMeta(meta) && (\n-            <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n-          )}\n-        </div>\n-      )}\n-      <div style={{ flex: 1, position: 'relative' }}>\n-        <PriceChart\n-          pairId={pairId}\n-          tf={tf}\n-          xDomain={xDomain}\n-          onXDomainChange={onXDomainChange}\n-          markers={showMarkers ? markers : []}\n-          chain={chain}\n-          poolAddress={poolAddress}\n-          tokenAddress={tokenAddress}\n-          tokenDetail={tokenDetail}\n-          displayMode={displayMode}\n-          onDisplayModeChange={setDisplayMode}\n-        />\n-      </div>\n-      \n-      {/* Chart info badges moved below */}\n-      <div className=\"chart-badges\" style={{ \n-        display: 'flex', \n-        justifyContent: 'space-between', \n-        alignItems: 'center',\n-        padding: 'var(--space-2) var(--space-4)',\n-        background: 'var(--bg-elev)',\n-        borderTop: '1px solid var(--border)',\n-        fontSize: '11px',\n-        color: 'var(--text-muted)',\n-      }}>\n-        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n-          {tf && (\n-            <span>UTC â€¢ {tf}</span>\n-          )}\n-          {/* Add provider info if available */}\n-        </div>\n-        <div style={{ display: 'flex', gap: 'var(--space-2)' }}>\n-          {meta && formatFetchMeta(meta) && (\n-            <span>{formatFetchMeta(meta)}</span>\n-          )}\n-        </div>\n-      </div>\n-    </div>\n-  );\n-}\n-\n"
                },
                {
                    "date": 1755801276982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,10 @@\n   // New chart configuration states\n   const [chartType, setChartType] = useState<'candlestick' | 'line'>('candlestick');\n   const [showVolume, setShowVolume] = useState(true);\n   const [crosshairMode, setCrosshairMode] = useState<'normal' | 'magnet'>('normal');\n+  const [showGrid, setShowGrid] = useState(true);\n+  const [showCrosshairLabels, setShowCrosshairLabels] = useState(true);\n   const loggedRef = useRef(false);\n   const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n \n   useEffect(() => {\n@@ -148,9 +150,9 @@\n \n   return (\n     <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n       <div className=\"chart-controls\">\n-        <div className=\"chart-controls-left\">\n+        <div className=\"chart-controls-left\" style={{ display: 'flex', alignItems: 'center', gap: 'var(--space-2)', flexWrap: 'wrap' }}>\n           <TimeframeSelector \n             selectedTf={tf}\n             availableTfs={availableTfs}\n             onTfChange={handleTfChange}\n@@ -219,17 +221,39 @@\n               Line\n             </button>\n           </div>\n           \n-          {/* Volume Toggle */}\n-          <label className=\"volume-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px' }}>\n-            <input \n-              type=\"checkbox\" \n-              checked={showVolume} \n-              onChange={(e) => setShowVolume(e.target.checked)}\n-            /> \n-            <span>Volume</span>\n-          </label>\n+          <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--space-2)' }}>\n+            {/* Volume Toggle */}\n+            <label className=\"volume-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px' }}>\n+              <input \n+                type=\"checkbox\" \n+                checked={showVolume} \n+                onChange={(e) => setShowVolume(e.target.checked)}\n+              /> \n+              <span>Volume</span>\n+            </label>\n+            \n+            {/* Grid Toggle */}\n+            <label className=\"grid-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px' }}>\n+              <input \n+                type=\"checkbox\" \n+                checked={showGrid} \n+                onChange={(e) => setShowGrid(e.target.checked)}\n+              /> \n+              <span>Grid</span>\n+            </label>\n+            \n+            {/* Crosshair Labels Toggle */}\n+            <label className=\"crosshair-labels-toggle\" style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px' }}>\n+              <input \n+                type=\"checkbox\" \n+                checked={showCrosshairLabels} \n+                onChange={(e) => setShowCrosshairLabels(e.target.checked)}\n+              /> \n+              <span>Labels</span>\n+            </label>\n+          </div>\n         </div>\n         <div className=\"chart-controls-right\">\n           {/* Crosshair Mode Toggle */}\n           <button\n@@ -244,10 +268,11 @@\n               color: crosshairMode === 'magnet' ? 'var(--bg)' : 'var(--text-muted)',\n               cursor: 'pointer'\n             }}\n             title={`Crosshair: ${crosshairMode}`}\n-          />\n+          >\n             {crosshairMode === 'magnet' ? 'ðŸ§²' : '+'}\n+          </button>\n         </div>\n       </div>\n       {showMarkers && noTrades && (\n         <div className=\"no-trades-notice\">\n@@ -256,25 +281,26 @@\n             <div className=\"meta-info\">{formatFetchMeta(meta)}</div>\n           )}\n         </div>\n       )}\n-      <div style={{ flex: 1, position: 'relative' }}>\n-        <PriceChart\n-          pairId={pairId}\n-          tf={tf}\n-          xDomain={xDomain}\n-          onXDomainChange={onXDomainChange}\n-          markers={showMarkers ? markers : []}\n-          chain={chain}\n-          poolAddress={poolAddress}\n-          tokenAddress={tokenAddress}\n-          tokenDetail={tokenDetail}\n-          displayMode={displayMode}\n-          onDisplayModeChange={setDisplayMode}\n-          chartType={chartType}\n-          showVolume={showVolume}\n-          crosshairMode={crosshairMode}\n-        />\n+      <div style={{ flex: 1, position: 'relative' }}>          <PriceChart\n+            pairId={pairId}\n+            tf={tf}\n+            xDomain={xDomain}\n+            onXDomainChange={onXDomainChange}\n+            markers={showMarkers ? markers : []}\n+            chain={chain}\n+            poolAddress={poolAddress}\n+            tokenAddress={tokenAddress}\n+            tokenDetail={tokenDetail}\n+            displayMode={displayMode}\n+            onDisplayModeChange={setDisplayMode}\n+            chartType={chartType}\n+            showVolume={showVolume}\n+            crosshairMode={crosshairMode}\n+            showGrid={showGrid}\n+            showCrosshairLabels={showCrosshairLabels}\n+          />\n       </div>\n       \n       {/* Chart info badges moved below */}\n       <div className=\"chart-badges\" style={{ \n"
                }
            ],
            "date": 1755352612658,
            "name": "Commit-0",
            "content": "import { useState, useEffect, useRef } from 'react';\nimport type { Timeframe, Provider } from '../../lib/types';\nimport PriceChart from './PriceChart';\nimport { getTradeMarkers, type TradeMarkerCluster } from '../trades/TradeMarkers';\nimport { ohlc } from '../../lib/api';\nimport { getCachedTf, setCachedTf } from '../../lib/tf-cache';\nimport { getTradesCache } from '../../lib/cache';\nimport { formatFetchMeta, type FetchMeta } from '../../lib/format';\n\ninterface Props {\n  pairId: string;\n  chain: string;\n  poolAddress: string;\n  provider: Provider;\n  xDomain: [number, number] | null;\n  onXDomainChange?: (d: [number, number]) => void;\n  tokenAddress: string;\n}\n\nexport default function ChartOnlyView({\n  pairId,\n  chain,\n  poolAddress,\n  provider,\n  xDomain,\n  onXDomainChange,\n  tokenAddress,\n}: Props) {\n  const [showMarkers, setShowMarkers] = useState(false);\n  const [markers, setMarkers] = useState<TradeMarkerCluster[]>([]);\n  const [noTrades, setNoTrades] = useState(false);\n  const [tf, setTf] = useState<Timeframe | null>(null);\n  const [meta, setMeta] = useState<FetchMeta | null>(null);\n  const loggedRef = useRef(false);\n  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n\n  useEffect(() => {\n    const cached = getCachedTf(pairId, provider);\n    if (cached) {\n      setTf(cached);\n      return;\n    }\n    const order: Timeframe[] =\n      provider === 'cg' ? ['1m', '5m'] : provider === 'gt' ? ['5m', '15m', '1h'] : ['1m'];\n    (async () => {\n      for (const t of order) {\n        try {\n          const res = await ohlc({ pairId, chain, poolAddress, tf: t });\n          if (res.data.candles.length > 0 || res.data.effectiveTf) {\n            const eff = res.data.effectiveTf || t;\n            setTf(eff);\n            setCachedTf(pairId, provider, eff);\n            break;\n          }\n        } catch {\n          /* ignore and try next */\n        }\n      }\n    })();\n  }, [pairId, provider, chain, poolAddress]);\n\n  useEffect(() => {\n    if (showMarkers) {\n      const m = getTradeMarkers(pairId, chain, poolAddress, tokenAddress);\n      setMarkers(m);\n      setNoTrades(m.length === 0);\n      const parts: string[] = [];\n      if (chain) parts.push(chain);\n      parts.push(pairId);\n      if (poolAddress) parts.push(poolAddress);\n      parts.push(tokenAddress);\n      const key = parts.join(':');\n      const cached = getTradesCache(key);\n      setMeta(cached?.meta || null);\n    }\n  }, [pairId, chain, poolAddress, tokenAddress, showMarkers]);\n\n  useEffect(() => {\n    if (showMarkers && noTrades && meta && !loggedRef.current && DEBUG) {\n      console.log('no-trades meta', meta);\n      loggedRef.current = true;\n    }\n  }, [showMarkers, noTrades, meta]);\n\n  function handleToggle() {\n    setShowMarkers((v) => {\n      const next = !v;\n      if (next) {\n        setMarkers(getTradeMarkers(pairId, chain, poolAddress, tokenAddress));\n      } else {\n        setMarkers([]);\n      }\n      return next;\n    });\n  }\n\n  if (!tf) {\n    return <div>Loadingâ€¦</div>;\n  }\n\n  return (\n    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n      <div style={{ padding: '16px 16px 8px', borderBottom: '1px solid var(--border-subtle)' }}>\n        <label style={{ \n          display: 'flex', \n          alignItems: 'center', \n          gap: '8px',\n          fontSize: '14px',\n          cursor: 'pointer'\n        }}>\n          <input \n            type=\"checkbox\" \n            checked={showMarkers} \n            onChange={handleToggle}\n            style={{ accentColor: 'var(--accent-telegram)' }}\n          /> \n          Trade markers\n        </label>\n      </div>\n      {showMarkers && noTrades && (\n        <div style={{ \n          padding: '8px 16px', \n          fontSize: '13px', \n          color: 'var(--text-muted)',\n          borderBottom: '1px solid var(--border-subtle)'\n        }}>\n          <div>No trades available</div>\n          {meta && formatFetchMeta(meta) && (\n            <div style={{ fontSize: '11px', marginTop: '4px' }}>{formatFetchMeta(meta)}</div>\n          )}\n        </div>\n      )}\n      <div style={{ flex: 1, position: 'relative' }}>\n        <PriceChart\n          pairId={pairId}\n          tf={tf}\n          xDomain={xDomain}\n          onXDomainChange={onXDomainChange}\n          markers={showMarkers ? markers : []}\n          chain={chain}\n          poolAddress={poolAddress}\n          tokenAddress={tokenAddress}\n        />\n      </div>\n    </div>\n  );\n}\n\n"
        }
    ]
}