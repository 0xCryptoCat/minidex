{
    "sourceFile": "src/features/chart/PriceChart.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755352612658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755352612658,
            "name": "Commit-0",
            "content": "import { useEffect, useRef, useState, useMemo } from 'react';\nimport { createChart, type IChartApi, type UTCTimestamp } from 'lightweight-charts';\nimport type { Timeframe, Candle } from '../../lib/types';\nimport { ohlc, trades } from '../../lib/api';\nimport { formatFetchMeta, type FetchMeta, formatUsd } from '../../lib/format';\nimport { createPoller } from '../../lib/polling';\nimport { rollupCandles } from '../../lib/time';\nimport type { TradeMarkerCluster } from '../trades/TradeMarkers';\nimport chains from '../../lib/chains.json';\n\nfunction toLWCandles(cs: { t: number; o: number; h: number; l: number; c: number }[]) {\n  const out: { time: number; open: number; high: number; low: number; close: number }[] = [];\n  let prevT = -Infinity;\n  for (const k of cs) {\n    const time = Math.floor(Number(k.t));\n    const open = Number(k.o);\n    const high = Number(k.h);\n    const low = Number(k.l);\n    const close = Number(k.c);\n    if (![time, open, high, low, close].every(Number.isFinite)) continue;\n    if (time <= prevT) continue;\n    out.push({ time, open, high, low, close });\n    prevT = time;\n  }\n  return out;\n}\n\ninterface Props {\n  pairId: string;\n  tf: Timeframe;\n  xDomain: [number, number] | null;\n  onXDomainChange?: (d: [number, number]) => void;\n  markers?: TradeMarkerCluster[];\n  chain: string;\n  poolAddress: string;\n  tokenAddress: string;\n}\n\nexport default function PriceChart({\n  pairId,\n  tf,\n  xDomain,\n  onXDomainChange,\n  markers = [],\n  chain,\n  poolAddress,\n  tokenAddress,\n}: Props) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const chartRef = useRef<IChartApi | null>(null);\n  const candleSeriesRef = useRef<any>(null);\n  const volumeSeriesRef = useRef<any>(null);\n  const markersMapRef = useRef<Map<number, TradeMarkerCluster[]>>(new Map());\n  const [hoveredMarkers, setHoveredMarkers] = useState<TradeMarkerCluster[] | null>(null);\n  const [provider, setProvider] = useState<string>('');\n  const [degraded, setDegraded] = useState(false);\n  const [hasData, setHasData] = useState(false);\n  const [effectiveTf, setEffectiveTf] = useState<Timeframe | undefined>();\n  const [meta, setMeta] = useState<FetchMeta | null>(null);\n  const loggedRef = useRef(false);\n  const sampleCandlesLoggedRef = useRef(false);\n  const rangeRafRef = useRef<number | null>(null);\n  const DEBUG = (import.meta as any).env?.DEBUG === 'true';\n\n  const explorerTemplate = useMemo(() => {\n    if (!chain) return undefined;\n    const entry: any = (chains as any[]).find((c) => c.slug === chain);\n    return entry?.explorerTx as string | undefined;\n  }, [chain]);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const chart = createChart(containerRef.current, { \n      height: containerRef.current.clientHeight || 400,\n      width: containerRef.current.clientWidth || 800 \n    });\n    const candleSeries = chart.addCandlestickSeries();\n    const volumeSeries = chart.addHistogramSeries({\n      priceScaleId: '',\n      priceFormat: { type: 'volume' },\n    });\n    volumeSeries.priceScale().applyOptions({\n      scaleMargins: { top: 0.8, bottom: 0 },\n    });\n    chartRef.current = chart;\n    candleSeriesRef.current = candleSeries;\n    volumeSeriesRef.current = volumeSeries;\n\n    function handleResize() {\n      const container = containerRef.current;\n      if (container) {\n        chart.applyOptions({ \n          width: container.clientWidth,\n          height: container.clientHeight || 400\n        });\n      }\n    }\n    handleResize();\n    window.addEventListener('resize', handleResize);\n\n    if (onXDomainChange) {\n      chart.timeScale().subscribeVisibleTimeRangeChange((range) => {\n        if (range && range.from !== undefined && range.to !== undefined) {\n          onXDomainChange([range.from as number, range.to as number]);\n        }\n      });\n    }\n\n    const crosshairHandler = (param: any) => {\n      if (param.time === undefined) {\n        setHoveredMarkers(null);\n        return;\n      }\n      const arr = markersMapRef.current.get(param.time as number);\n      setHoveredMarkers(arr || null);\n    };\n    chart.subscribeCrosshairMove(crosshairHandler);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      chart.unsubscribeCrosshairMove(crosshairHandler);\n      chart.remove();\n    };\n  }, [onXDomainChange]);\n\n  useEffect(() => {\n    if (!chartRef.current || !xDomain || !hasData) return;\n    const [from, to] = xDomain;\n    if (!Number.isFinite(from) || !Number.isFinite(to) || from >= to) return;\n    const chart = chartRef.current;\n    rangeRafRef.current = requestAnimationFrame(() => {\n      try {\n        chart.timeScale().setVisibleRange({ from: from as any, to: to as any });\n      } catch {\n        // ignore if chart was destroyed\n      }\n    });\n    return () => {\n      if (rangeRafRef.current) {\n        cancelAnimationFrame(rangeRafRef.current);\n        rangeRafRef.current = null;\n      }\n    };\n  }, [xDomain, hasData]);\n\n  useEffect(() => {\n    markersMapRef.current.clear();\n    if (!markers || markers.length === 0) {\n      candleSeriesRef.current?.setMarkers([]);\n      return;\n    }\n    markers.forEach((m) => {\n      const arr = markersMapRef.current.get(m.ts) || [];\n      arr.push(m);\n      markersMapRef.current.set(m.ts, arr);\n    });\n    if (candleSeriesRef.current) {\n      const formatted = markers.map((m) => ({\n        time: m.ts as UTCTimestamp,\n        position: m.side === 'buy' ? 'belowBar' : 'aboveBar',\n        color: m.side === 'buy' ? '#32cd32' : '#ff00ff',\n        shape: m.side === 'buy' ? 'arrowUp' : 'arrowDown',\n        text: m.clusterSize && m.clusterSize > 1 ? String(m.clusterSize) : undefined,\n      }));\n      candleSeriesRef.current.setMarkers(formatted);\n    }\n  }, [markers]);\n\n  useEffect(() => {\n    if (!pairId || !chain || !poolAddress) return;\n    let candles: Candle[] = [];\n\n    candleSeriesRef.current?.setData([]);\n    volumeSeriesRef.current?.setData([]);\n\n    const poller = createPoller(async () => {\n      const { data, meta } = await ohlc({ pairId, tf, chain, poolAddress });\n      setMeta(meta);\n      candles = data.candles;\n      if (data.rollupHint === 'client' && data.tf !== tf) {\n        candles = rollupCandles(candles, data.tf, tf);\n      }\n      setEffectiveTf(data.effectiveTf);\n      const cleaned = toLWCandles(candles);\n      if (candles.length > 0 && cleaned.length === candles.length) {\n        const c = cleaned.map((cd) => ({\n          time: cd.time as UTCTimestamp,\n          open: cd.open,\n          high: cd.high,\n          low: cd.low,\n          close: cd.close,\n        }));\n        const v = c.map((cd) => {\n          const src = candles.find((k) => Math.floor(Number(k.t)) === cd.time);\n          const vol = src && Number.isFinite(Number(src.v)) ? Number(src.v) : 0;\n          return {\n            time: cd.time as UTCTimestamp,\n            value: vol,\n            color: cd.close >= cd.open ? '#26a69a' : '#ef5350',\n          };\n        });\n        candleSeriesRef.current?.setData(c);\n        volumeSeriesRef.current?.setData(v);\n        setHasData(true);\n        if (!sampleCandlesLoggedRef.current && DEBUG) {\n          console.log('sample candles', candles.slice(0, 2).map((cd) => ({ t: cd.t, o: cd.o, h: cd.h, l: cd.l, c: cd.c })));\n          sampleCandlesLoggedRef.current = true;\n        }\n      } else {\n        setHasData(false);\n      }\n      setProvider(data.provider);\n    }, 5000, {\n      onError: () => setDegraded(true),\n      onRecover: () => setDegraded(false),\n    });\n    poller.start();\n\n    const tradesPoller = createPoller(async () => {\n      const { data: tr } = await trades({ pairId, chain, poolAddress, tokenAddress });\n      if (tr && Array.isArray(tr.trades) && tr.trades.length > 0) {\n        // noop: data is cached in trades() and used elsewhere\n      }\n    }, 3000, {\n      onError: () => setDegraded(true),\n      onRecover: () => setDegraded(false),\n    });\n    tradesPoller.start();\n\n    return () => {\n      poller.stop();\n      tradesPoller.stop();\n    };\n  }, [pairId, tf, chain, poolAddress, tokenAddress]);\n\n  useEffect(() => {\n    if (!hasData && meta && !loggedRef.current && DEBUG) {\n      console.log('no-data meta', meta);\n      loggedRef.current = true;\n    }\n  }, [hasData, meta]);\n\n  return (\n    <div style={{ position: 'relative', height: '100%', minHeight: '400px' }}>\n      {degraded && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            background: 'rgba(255,46,209,0.2)',\n            color: 'var(--accent-magenta)',\n            padding: '2px 4px',\n            fontSize: '12px',\n            textAlign: 'center',\n            zIndex: 1,\n          }}\n        >\n          degraded\n        </div>\n      )}\n      <div ref={containerRef} style={{ height: '100%', minHeight: '400px' }} />\n      {!hasData && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n            color: 'var(--text-muted)',\n            pointerEvents: 'none',\n            flexDirection: 'column',\n          }}\n        >\n          <div>No chart data available</div>\n          {meta && formatFetchMeta(meta) && (\n            <div style={{ fontSize: '10px', marginTop: 4 }}>{formatFetchMeta(meta)}</div>\n          )}\n        </div>\n      )}\n      {hoveredMarkers && hoveredMarkers.length > 0 && (\n        <div\n          style={{\n            position: 'absolute',\n            left: 4,\n            top: 4,\n            background: 'rgba(0,0,0,0.7)',\n            color: 'var(--text)',\n            padding: '4px',\n            fontSize: '12px',\n            zIndex: 2,\n          }}\n        >\n          {hoveredMarkers.map((m, i) => {\n            const link = explorerTemplate && m.txHash ? explorerTemplate.replace('{tx}', m.txHash) : undefined;\n            return (\n              <div key={i} style={{ marginBottom: 4 }}>\n                <div style={{ color: m.side === 'buy' ? 'var(--accent-lime)' : 'var(--accent-magenta)' }}>\n                  {m.side} {m.size?.toFixed(2)} @ {formatUsd(m.price)}\n                  {m.clusterSize && m.clusterSize > 1 ? ` (${m.clusterSize})` : ''}\n                </div>\n                {m.walletShort && m.clusterSize === 1 && <div>{m.walletShort}</div>}\n                {link && m.clusterSize === 1 && (\n                  <div>\n                    <a href={link} target=\"_blank\" rel=\"noreferrer\" style={{ color: '#4ea3ff' }}>\n                      tx\n                    </a>\n                  </div>\n                )}\n              </div>\n            );\n          })}\n        </div>\n      )}\n      {effectiveTf && effectiveTf !== tf && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            background: 'var(--bg)',\n            color: 'var(--text)',\n            padding: '2px 4px',\n            fontSize: '10px',\n            opacity: 0.7,\n          }}\n        >\n          TF downgraded to {effectiveTf}\n        </div>\n      )}\n      {provider && (\n        <div\n          style={{\n            position: 'absolute',\n            top: 4,\n            right: 4,\n            background: 'var(--bg)',\n            color: 'var(--text)',\n            padding: '2px 4px',\n            fontSize: '10px',\n            opacity: 0.7,\n          }}\n        >\n          {provider}\n        </div>\n      )}\n      <div\n        style={{\n          fontSize: '10px',\n          textAlign: 'center',\n          marginTop: 4,\n        }}\n      >\n        UTC | TF: {effectiveTf || tf}\n      </div>\n    </div>\n  );\n}\n\n"
        }
    ]
}