{
    "sourceFile": "src/lib/format.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755347748705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755347748705,
            "name": "Commit-0",
            "content": "import type { ReactNode } from 'react';\n\nconst formatter = new Intl.NumberFormat(undefined, {\n  notation: 'compact',\n  maximumFractionDigits: 2,\n});\n\nexport function formatCompact(value?: number): string {\n  if (value === undefined || value === null || isNaN(value)) return '-';\n  return formatter.format(value);\n}\n\nexport function formatUsd(\n  value?: number,\n  opts?: { compact?: boolean; dp?: number }\n): string {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  const dp = opts?.dp ?? 4;\n  if (Math.abs(value) >= 1000 && opts?.compact !== false)\n    return `$${formatCompact(value)}`;\n  return `$${value.toFixed(dp)}`;\n}\n\nexport function formatDateTimeUTC(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const d = new Date(ts * 1000);\n  return d.toISOString().replace('T', ' ').replace(/\\.\\d+Z$/, ' UTC');\n}\n\nexport function formatTimeUTC(ts: number): string {\n  const d = new Date(ts * 1000);\n  const fmt = new Intl.DateTimeFormat('en-GB', {\n    timeZone: 'UTC',\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n  return `${fmt.format(d)} UTC`;\n}\n\nexport function formatShortAddr(addr?: string): string {\n  if (!addr) return '-';\n  return `${addr.slice(0, 2)}…${addr.slice(-4)}`;\n}\n\nexport function subscriptZeros(frac: string): ReactNode[] {\n  return frac.split('').map((c, i) =>\n    c === '0' ? (\n      <span key={i} className=\"sub\">\n        0\n      </span>\n    ) : (\n      c\n    )\n  );\n}\n\nexport function formatAmount(value?: number): ReactNode {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  if (value === 0) return '0';\n  const abs = Math.abs(value);\n  if (abs >= 1) return value.toFixed(2);\n\n  const str = value.toString();\n  if (str.includes('e-')) {\n    const [m, e] = str.split('e-');\n    const zeros = Number(e) - 1;\n    const digits = m.replace('.', '').slice(0, 4);\n    return (\n      <>\n        0.\n        {subscriptZeros('0'.repeat(zeros))}\n        {digits}\n      </>\n    );\n  }\n\n  const [intPart, fracPartRaw = '0'] = str.split('.');\n  const fracPart = fracPartRaw.replace(/0+$/, '');\n  const match = fracPart.match(/^(0+)(\\d+)/);\n  if (match) {\n    const [, zeros, rest] = match;\n    return (\n      <>\n        {intPart}.\n        {subscriptZeros(zeros)}\n        {rest.slice(0, 4)}\n      </>\n    );\n  }\n  return `${intPart}.${fracPart.slice(0, 4)}`;\n}\n\nexport function formatAge(createdTs?: number): string {\n  if (!createdTs) return '-';\n  const now = Math.floor(Date.now() / 1000);\n  let diff = now - createdTs;\n  if (diff < 0) diff = 0;\n  const days = Math.floor(diff / 86400);\n  const hours = Math.floor((diff % 86400) / 3600);\n  const minutes = Math.floor((diff % 3600) / 60);\n  if (days > 0) return `${days}d ${hours}h`;\n  return `${hours}h ${minutes}m`;\n}\n\nexport function formatTimeAgo(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const now = Date.now();\n  const tradeTime = ts * 1000;\n  const diff = now - tradeTime;\n\n  const seconds = Math.floor(diff / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (days > 0) return `${days}d ago`;\n  if (hours > 0) return `${hours}h ago`;\n  if (minutes > 0) return `${minutes}m ago`;\n  return `${seconds}s ago`;\n}\n\nexport function formatCompactTime(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const d = new Date(ts * 1000);\n  const now = new Date();\n  const diffHours = (now.getTime() - d.getTime()) / (1000 * 60 * 60);\n\n  if (diffHours < 24) {\n    return formatTimeAgo(ts);\n  }\n\n  const month = d.toLocaleDateString('en-US', { month: 'short' });\n  const day = d.getDate();\n  const time = d.toLocaleTimeString('en-US', {\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  return `${month} ${day} ${time} UTC`;\n}\n\nexport function formatSmartAmount(value?: number): string {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  if (value === 0) return '0';\n\n  const abs = Math.abs(value);\n\n  // For very small numbers (< 0.0001), show with subscript zeros\n  if (abs < 0.0001 && abs > 0) {\n    const str = abs.toString();\n    if (str.includes('e-')) {\n      const [m, e] = str.split('e-');\n      const zeros = Number(e) - 1;\n      const digits = m.replace('.', '').slice(0, 4);\n      return `0.0{${zeros}}${digits}`;\n    }\n  }\n\n  // For numbers >= 1000, use compact notation\n  if (abs >= 1000) {\n    if (abs >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\n    if (abs >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\n    if (abs >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\n  }\n\n  // For numbers >= 1, use 2 decimal places\n  if (abs >= 1) return value.toFixed(2);\n\n  // For small numbers, use up to 4 significant digits\n  return value.toPrecision(4);\n}\n\nimport type { FetchMeta } from './types';\nexport type { FetchMeta } from './types';\n\nexport function formatFetchMeta(meta?: FetchMeta): string | undefined {\n  if (!meta) return undefined;\n  const parts: string[] = [];\n  let reason: string | undefined;\n  const tried = meta.tried?.split(',').filter(Boolean);\n  if (tried && tried.length > 0) {\n    const provs = tried.map((t) => {\n      const [p, r] = t.split(':');\n      if (r && !reason) reason = `${p}:${r}`;\n      return p;\n    });\n    let base = `Tried: ${provs.join('→')}`;\n    if (meta.effectiveTf) base += ` (tf: ${meta.effectiveTf})`;\n    parts.push(base);\n  } else if (meta.effectiveTf) {\n    parts.push(`TF: ${meta.effectiveTf}`);\n  }\n  if (meta.provider) parts.push(`Provider: ${meta.provider}`);\n  if (meta.items) parts.push(`Items: ${meta.items}`);\n  if (reason) parts.push(`reason: ${reason}`);\n  if (meta.remapped && meta.remapped !== '0') parts.push('remap: yes');\n  if (meta.invalidPool) parts.push(`invalid-pool: ${meta.invalidPool}`);\n  if (meta.cgAuth) parts.push(`cg-auth: ${meta.cgAuth}`);\n  if (meta.token) parts.push(`token: ${meta.token}`);\n  if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n  return parts.join(' | ');\n}\n\n"
        }
    ]
}