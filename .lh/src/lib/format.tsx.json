{
    "sourceFile": "src/lib/format.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1755347748705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1755361663379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,233 @@\n+import type { ReactNode } from 'react';\n+\n+const formatter = new Intl.NumberFormat(undefined, {\n+  notation: 'compact',\n+  maximumFractionDigits: 2,\n+});\n+\n+export function formatCompact(value?: number): string {\n+  if (value === undefined || value === null || isNaN(value)) return '-';\n+  return formatter.format(value);\n+}\n+\n+export function formatUsd(\n+  value?: number,\n+  opts?: { compact?: boolean; dp?: number }\n+): string {\n+  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n+  const dp = opts?.dp ?? 4;\n+  if (Math.abs(value) >= 1000 && opts?.compact !== false)\n+    return `$${formatCompact(value)}`;\n+  return `$${value.toFixed(dp)}`;\n+}\n+\n+export function formatDateTimeUTC(ts?: number): string {\n+  if (!ts && ts !== 0) return '-';\n+  const d = new Date(ts * 1000);\n+  return d.toISOString().replace('T', ' ').replace(/\\.\\d+Z$/, ' UTC');\n+}\n+\n+export function formatTimeUTC(ts: number): string {\n+  const d = new Date(ts * 1000);\n+  const fmt = new Intl.DateTimeFormat('en-GB', {\n+    timeZone: 'UTC',\n+    year: 'numeric',\n+    month: '2-digit',\n+    day: '2-digit',\n+    hour: '2-digit',\n+    minute: '2-digit',\n+    second: '2-digit',\n+    hour12: false,\n+  });\n+  return `${fmt.format(d)} UTC`;\n+}\n+\n+export function formatShortAddr(addr?: string): string {\n+  if (!addr) return '-';\n+  return `${addr.slice(0, 2)}…${addr.slice(-4)}`;\n+}\n+\n+export function subscriptZeros(frac: string): ReactNode[] {\n+  return frac.split('').map((c, i) =>\n+    c === '0' ? (\n+      <span key={i} className=\"sub\">\n+        0\n+      </span>\n+    ) : (\n+      c\n+    )\n+  );\n+}\n+\n+export function formatAmount(value?: number): ReactNode {\n+  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n+  if (value === 0) return '0';\n+  const abs = Math.abs(value);\n+  if (abs >= 1) return value.toFixed(2);\n+\n+  const str = value.toString();\n+  if (str.includes('e-')) {\n+    const [m, e] = str.split('e-');\n+    const zeros = Number(e) - 1;\n+    const digits = m.replace('.', '').slice(0, 4);\n+    return (\n+      <>\n+        0.\n+        {subscriptZeros('0'.repeat(zeros))}\n+        {digits}\n+      </>\n+    );\n+  }\n+\n+  const [intPart, fracPartRaw = '0'] = str.split('.');\n+  const fracPart = fracPartRaw.replace(/0+$/, '');\n+  const match = fracPart.match(/^(0+)(\\d+)/);\n+  if (match) {\n+    const [, zeros, rest] = match;\n+    return (\n+      <>\n+        {intPart}.\n+        {subscriptZeros(zeros)}\n+        {rest.slice(0, 4)}\n+      </>\n+    );\n+  }\n+  return `${intPart}.${fracPart.slice(0, 4)}`;\n+}\n+\n+export function formatAge(createdTs?: number): string {\n+  if (!createdTs) return '-';\n+  const now = Math.floor(Date.now() / 1000);\n+  let diff = now - createdTs;\n+  if (diff < 0) diff = 0;\n+  const days = Math.floor(diff / 86400);\n+  const hours = Math.floor((diff % 86400) / 3600);\n+  const minutes = Math.floor((diff % 3600) / 60);\n+  if (days > 0) return `${days}d ${hours}h`;\n+  return `${hours}h ${minutes}m`;\n+}\n+\n+export function formatTimeAgo(ts?: number): string {\n+  if (!ts && ts !== 0) return '-';\n+  const now = Date.now();\n+  const tradeTime = ts * 1000;\n+  const diff = now - tradeTime;\n+\n+  const seconds = Math.floor(diff / 1000);\n+  const minutes = Math.floor(seconds / 60);\n+  const hours = Math.floor(minutes / 60);\n+  const days = Math.floor(hours / 24);\n+\n+  if (days > 0) return `${days}d ago`;\n+  if (hours > 0) return `${hours}h ago`;\n+  if (minutes > 0) return `${minutes}m ago`;\n+  return `${seconds}s ago`;\n+}\n+\n+export function formatCompactTime(ts?: number): string {\n+  if (!ts && ts !== 0) return '-';\n+  const d = new Date(ts * 1000);\n+  const now = new Date();\n+  const diffHours = (now.getTime() - d.getTime()) / (1000 * 60 * 60);\n+\n+  if (diffHours < 24) {\n+    return formatTimeAgo(ts);\n+  }\n+\n+  const month = d.toLocaleDateString('en-US', { month: 'short' });\n+  const day = d.getDate();\n+  const time = d.toLocaleTimeString('en-US', {\n+    hour: '2-digit',\n+    minute: '2-digit',\n+    second: '2-digit',\n+    hour12: false,\n+  });\n+\n+  return `${month} ${day} ${time} UTC`;\n+}\n+\n+export function formatSmartAmount(value?: number): string {\n+  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n+  if (value === 0) return '0';\n+\n+  const abs = Math.abs(value);\n+\n+  // For very small numbers (< 0.0001), show with subscript zeros\n+  if (abs < 0.0001 && abs > 0) {\n+    const str = abs.toString();\n+    if (str.includes('e-')) {\n+      const [m, e] = str.split('e-');\n+      const zeros = Number(e) - 1;\n+      const digits = m.replace('.', '').slice(0, 4);\n+      return `0.0{${zeros}}${digits}`;\n+    }\n+  }\n+\n+  // For numbers >= 1000, use compact notation\n+  if (abs >= 1000) {\n+    if (abs >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\n+    if (abs >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\n+    if (abs >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\n+  }\n+\n+  // For numbers >= 1, use 2 decimal places\n+  if (abs >= 1) return value.toFixed(2);\n+\n+  // For small numbers, use up to 4 significant digits\n+  return value.toPrecision(4);\n+}\n+\n+export function formatSmallPrice(value?: number): string {\n+  if (value === undefined || value === null || !Number.isFinite(value)) return '—';\n+  if (value === 0) return '$0.00';\n+\n+  // For very small numbers, use subscript notation like 0.0₆32\n+  if (Math.abs(value) < 0.0001 && Math.abs(value) > 0) {\n+    const str = value.toString();\n+    const match = str.match(/0\\.0+/);\n+    if (match) {\n+      const zeros = match[0].length - 2; // subtract \"0.\"\n+      const remaining = str.slice(match[0].length);\n+      const significantDigits = remaining.slice(0, 2);\n+      return `$0.0₀${zeros}${significantDigits}`;\n+    }\n+  }\n+\n+  if (Math.abs(value) < 1) {\n+    return `$${value.toFixed(6).replace(/\\.?0+$/, '')}`;\n+  }\n+\n+  return formatUsd(value);\n+}\n+\n+import type { FetchMeta } from './types';\n+export type { FetchMeta } from './types';\n+\n+export function formatFetchMeta(meta?: FetchMeta): string | undefined {\n+  if (!meta) return undefined;\n+  const parts: string[] = [];\n+  let reason: string | undefined;\n+  const tried = meta.tried?.split(',').filter(Boolean);\n+  if (tried && tried.length > 0) {\n+    const provs = tried.map((t) => {\n+      const [p, r] = t.split(':');\n+      if (r && !reason) reason = `${p}:${r}`;\n+      return p;\n+    });\n+    let base = `Tried: ${provs.join('→')}`;\n+    if (meta.effectiveTf) base += ` (tf: ${meta.effectiveTf})`;\n+    parts.push(base);\n+  } else if (meta.effectiveTf) {\n+    parts.push(`TF: ${meta.effectiveTf}`);\n+  }\n+  if (meta.provider) parts.push(`Provider: ${meta.provider}`);\n+  if (meta.items) parts.push(`Items: ${meta.items}`);\n+  if (reason) parts.push(`reason: ${reason}`);\n+  if (meta.remapped && meta.remapped !== '0') parts.push('remap: yes');\n+  if (meta.invalidPool) parts.push(`invalid-pool: ${meta.invalidPool}`);\n+  if (meta.cgAuth) parts.push(`cg-auth: ${meta.cgAuth}`);\n+  if (meta.token) parts.push(`token: ${meta.token}`);\n+  if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n+  return parts.join(' | ');\n+}\n+\n"
                },
                {
                    "date": 1755363517974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,11 +117,11 @@\n   const minutes = Math.floor(seconds / 60);\n   const hours = Math.floor(minutes / 60);\n   const days = Math.floor(hours / 24);\n \n-  if (days > 0) return `${days}d ago`;\n-  if (hours > 0) return `${hours}h ago`;\n-  if (minutes > 0) return `${minutes}m ago`;\n+  if (days > 0) return `${days}d`;\n+  if (hours > 0) return `${hours}h`;\n+  if (minutes > 0) return `${minutes}m`;\n   return `${seconds}s ago`;\n }\n \n export function formatCompactTime(ts?: number): string {\n@@ -230,214 +230,4 @@\n   if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n   return parts.join(' | ');\n }\n \n-import type { ReactNode } from 'react';\n-\n-const formatter = new Intl.NumberFormat(undefined, {\n-  notation: 'compact',\n-  maximumFractionDigits: 2,\n-});\n-\n-export function formatCompact(value?: number): string {\n-  if (value === undefined || value === null || isNaN(value)) return '-';\n-  return formatter.format(value);\n-}\n-\n-export function formatUsd(\n-  value?: number,\n-  opts?: { compact?: boolean; dp?: number }\n-): string {\n-  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n-  const dp = opts?.dp ?? 4;\n-  if (Math.abs(value) >= 1000 && opts?.compact !== false)\n-    return `$${formatCompact(value)}`;\n-  return `$${value.toFixed(dp)}`;\n-}\n-\n-export function formatDateTimeUTC(ts?: number): string {\n-  if (!ts && ts !== 0) return '-';\n-  const d = new Date(ts * 1000);\n-  return d.toISOString().replace('T', ' ').replace(/\\.\\d+Z$/, ' UTC');\n-}\n-\n-export function formatTimeUTC(ts: number): string {\n-  const d = new Date(ts * 1000);\n-  const fmt = new Intl.DateTimeFormat('en-GB', {\n-    timeZone: 'UTC',\n-    year: 'numeric',\n-    month: '2-digit',\n-    day: '2-digit',\n-    hour: '2-digit',\n-    minute: '2-digit',\n-    second: '2-digit',\n-    hour12: false,\n-  });\n-  return `${fmt.format(d)} UTC`;\n-}\n-\n-export function formatShortAddr(addr?: string): string {\n-  if (!addr) return '-';\n-  return `${addr.slice(0, 2)}…${addr.slice(-4)}`;\n-}\n-\n-export function subscriptZeros(frac: string): ReactNode[] {\n-  return frac.split('').map((c, i) =>\n-    c === '0' ? (\n-      <span key={i} className=\"sub\">\n-        0\n-      </span>\n-    ) : (\n-      c\n-    )\n-  );\n-}\n-\n-export function formatAmount(value?: number): ReactNode {\n-  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n-  if (value === 0) return '0';\n-  const abs = Math.abs(value);\n-  if (abs >= 1) return value.toFixed(2);\n-\n-  const str = value.toString();\n-  if (str.includes('e-')) {\n-    const [m, e] = str.split('e-');\n-    const zeros = Number(e) - 1;\n-    const digits = m.replace('.', '').slice(0, 4);\n-    return (\n-      <>\n-        0.\n-        {subscriptZeros('0'.repeat(zeros))}\n-        {digits}\n-      </>\n-    );\n-  }\n-\n-  const [intPart, fracPartRaw = '0'] = str.split('.');\n-  const fracPart = fracPartRaw.replace(/0+$/, '');\n-  const match = fracPart.match(/^(0+)(\\d+)/);\n-  if (match) {\n-    const [, zeros, rest] = match;\n-    return (\n-      <>\n-        {intPart}.\n-        {subscriptZeros(zeros)}\n-        {rest.slice(0, 4)}\n-      </>\n-    );\n-  }\n-  return `${intPart}.${fracPart.slice(0, 4)}`;\n-}\n-\n-export function formatAge(createdTs?: number): string {\n-  if (!createdTs) return '-';\n-  const now = Math.floor(Date.now() / 1000);\n-  let diff = now - createdTs;\n-  if (diff < 0) diff = 0;\n-  const days = Math.floor(diff / 86400);\n-  const hours = Math.floor((diff % 86400) / 3600);\n-  const minutes = Math.floor((diff % 3600) / 60);\n-  if (days > 0) return `${days}d ${hours}h`;\n-  return `${hours}h ${minutes}m`;\n-}\n-\n-export function formatTimeAgo(ts?: number): string {\n-  if (!ts && ts !== 0) return '-';\n-  const now = Date.now();\n-  const tradeTime = ts * 1000;\n-  const diff = now - tradeTime;\n-\n-  const seconds = Math.floor(diff / 1000);\n-  const minutes = Math.floor(seconds / 60);\n-  const hours = Math.floor(minutes / 60);\n-  const days = Math.floor(hours / 24);\n-\n-  if (days > 0) return `${days}d ago`;\n-  if (hours > 0) return `${hours}h ago`;\n-  if (minutes > 0) return `${minutes}m ago`;\n-  return `${seconds}s ago`;\n-}\n-\n-export function formatCompactTime(ts?: number): string {\n-  if (!ts && ts !== 0) return '-';\n-  const d = new Date(ts * 1000);\n-  const now = new Date();\n-  const diffHours = (now.getTime() - d.getTime()) / (1000 * 60 * 60);\n-\n-  if (diffHours < 24) {\n-    return formatTimeAgo(ts);\n-  }\n-\n-  const month = d.toLocaleDateString('en-US', { month: 'short' });\n-  const day = d.getDate();\n-  const time = d.toLocaleTimeString('en-US', {\n-    hour: '2-digit',\n-    minute: '2-digit',\n-    second: '2-digit',\n-    hour12: false,\n-  });\n-\n-  return `${month} ${day} ${time} UTC`;\n-}\n-\n-export function formatSmartAmount(value?: number): string {\n-  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n-  if (value === 0) return '0';\n-\n-  const abs = Math.abs(value);\n-\n-  // For very small numbers (< 0.0001), show with subscript zeros\n-  if (abs < 0.0001 && abs > 0) {\n-    const str = abs.toString();\n-    if (str.includes('e-')) {\n-      const [m, e] = str.split('e-');\n-      const zeros = Number(e) - 1;\n-      const digits = m.replace('.', '').slice(0, 4);\n-      return `0.0{${zeros}}${digits}`;\n-    }\n-  }\n-\n-  // For numbers >= 1000, use compact notation\n-  if (abs >= 1000) {\n-    if (abs >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\n-    if (abs >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\n-    if (abs >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\n-  }\n-\n-  // For numbers >= 1, use 2 decimal places\n-  if (abs >= 1) return value.toFixed(2);\n-\n-  // For small numbers, use up to 4 significant digits\n-  return value.toPrecision(4);\n-}\n-\n-import type { FetchMeta } from './types';\n-export type { FetchMeta } from './types';\n-\n-export function formatFetchMeta(meta?: FetchMeta): string | undefined {\n-  if (!meta) return undefined;\n-  const parts: string[] = [];\n-  let reason: string | undefined;\n-  const tried = meta.tried?.split(',').filter(Boolean);\n-  if (tried && tried.length > 0) {\n-    const provs = tried.map((t) => {\n-      const [p, r] = t.split(':');\n-      if (r && !reason) reason = `${p}:${r}`;\n-      return p;\n-    });\n-    let base = `Tried: ${provs.join('→')}`;\n-    if (meta.effectiveTf) base += ` (tf: ${meta.effectiveTf})`;\n-    parts.push(base);\n-  } else if (meta.effectiveTf) {\n-    parts.push(`TF: ${meta.effectiveTf}`);\n-  }\n-  if (meta.provider) parts.push(`Provider: ${meta.provider}`);\n-  if (meta.items) parts.push(`Items: ${meta.items}`);\n-  if (reason) parts.push(`reason: ${reason}`);\n-  if (meta.remapped && meta.remapped !== '0') parts.push('remap: yes');\n-  if (meta.invalidPool) parts.push(`invalid-pool: ${meta.invalidPool}`);\n-  if (meta.cgAuth) parts.push(`cg-auth: ${meta.cgAuth}`);\n-  if (meta.token) parts.push(`token: ${meta.token}`);\n-  if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n-  return parts.join(' | ');\n-}\n-\n"
                },
                {
                    "date": 1755429041170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n \n   if (days > 0) return `${days}d`;\n   if (hours > 0) return `${hours}h`;\n   if (minutes > 0) return `${minutes}m`;\n-  return `${seconds}s ago`;\n+  return `${seconds}s`;\n }\n \n export function formatCompactTime(ts?: number): string {\n   if (!ts && ts !== 0) return '-';\n@@ -230,4 +230,49 @@\n   if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n   return parts.join(' | ');\n }\n \n+export function formatSmartAmountReact(value?: number): ReactNode {\n+  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n+  if (value === 0) return '0';\n+\n+  const abs = Math.abs(value);\n+\n+  // For very small numbers (< 0.0001), use the same logic as formatAmount\n+  if (abs < 0.0001 && abs > 0) {\n+    return formatAmount(value);\n+  }\n+\n+  // For numbers >= 1000, use compact notation\n+  if (abs >= 1000) {\n+    if (abs >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\n+    if (abs >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\n+    if (abs >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\n+  }\n+\n+  // For numbers >= 1, use 2 decimal places\n+  if (abs >= 1) return value.toFixed(2);\n+\n+  // For small numbers < 1, limit to 4 decimal places and use subscript for leading zeros\n+  const fixed = value.toFixed(8);\n+  const [intPart, fracPart = ''] = fixed.split('.');\n+  \n+  // Find leading zeros\n+  const leadingZerosMatch = fracPart.match(/^(0+)/);\n+  if (leadingZerosMatch && leadingZerosMatch[1].length > 0) {\n+    const zeros = leadingZerosMatch[1];\n+    const rest = fracPart.slice(zeros.length, zeros.length + 4);\n+    if (zeros.length >= 2) {\n+      return (\n+        <>\n+          {intPart}.\n+          {subscriptZeros(zeros)}\n+          {rest}\n+        </>\n+      );\n+    }\n+  }\n+  \n+  // Default: show up to 4 decimal places\n+  return value.toFixed(4).replace(/\\.?0+$/, '');\n+}\n+\n"
                }
            ],
            "date": 1755347748705,
            "name": "Commit-0",
            "content": "import type { ReactNode } from 'react';\n\nconst formatter = new Intl.NumberFormat(undefined, {\n  notation: 'compact',\n  maximumFractionDigits: 2,\n});\n\nexport function formatCompact(value?: number): string {\n  if (value === undefined || value === null || isNaN(value)) return '-';\n  return formatter.format(value);\n}\n\nexport function formatUsd(\n  value?: number,\n  opts?: { compact?: boolean; dp?: number }\n): string {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  const dp = opts?.dp ?? 4;\n  if (Math.abs(value) >= 1000 && opts?.compact !== false)\n    return `$${formatCompact(value)}`;\n  return `$${value.toFixed(dp)}`;\n}\n\nexport function formatDateTimeUTC(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const d = new Date(ts * 1000);\n  return d.toISOString().replace('T', ' ').replace(/\\.\\d+Z$/, ' UTC');\n}\n\nexport function formatTimeUTC(ts: number): string {\n  const d = new Date(ts * 1000);\n  const fmt = new Intl.DateTimeFormat('en-GB', {\n    timeZone: 'UTC',\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n  return `${fmt.format(d)} UTC`;\n}\n\nexport function formatShortAddr(addr?: string): string {\n  if (!addr) return '-';\n  return `${addr.slice(0, 2)}…${addr.slice(-4)}`;\n}\n\nexport function subscriptZeros(frac: string): ReactNode[] {\n  return frac.split('').map((c, i) =>\n    c === '0' ? (\n      <span key={i} className=\"sub\">\n        0\n      </span>\n    ) : (\n      c\n    )\n  );\n}\n\nexport function formatAmount(value?: number): ReactNode {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  if (value === 0) return '0';\n  const abs = Math.abs(value);\n  if (abs >= 1) return value.toFixed(2);\n\n  const str = value.toString();\n  if (str.includes('e-')) {\n    const [m, e] = str.split('e-');\n    const zeros = Number(e) - 1;\n    const digits = m.replace('.', '').slice(0, 4);\n    return (\n      <>\n        0.\n        {subscriptZeros('0'.repeat(zeros))}\n        {digits}\n      </>\n    );\n  }\n\n  const [intPart, fracPartRaw = '0'] = str.split('.');\n  const fracPart = fracPartRaw.replace(/0+$/, '');\n  const match = fracPart.match(/^(0+)(\\d+)/);\n  if (match) {\n    const [, zeros, rest] = match;\n    return (\n      <>\n        {intPart}.\n        {subscriptZeros(zeros)}\n        {rest.slice(0, 4)}\n      </>\n    );\n  }\n  return `${intPart}.${fracPart.slice(0, 4)}`;\n}\n\nexport function formatAge(createdTs?: number): string {\n  if (!createdTs) return '-';\n  const now = Math.floor(Date.now() / 1000);\n  let diff = now - createdTs;\n  if (diff < 0) diff = 0;\n  const days = Math.floor(diff / 86400);\n  const hours = Math.floor((diff % 86400) / 3600);\n  const minutes = Math.floor((diff % 3600) / 60);\n  if (days > 0) return `${days}d ${hours}h`;\n  return `${hours}h ${minutes}m`;\n}\n\nexport function formatTimeAgo(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const now = Date.now();\n  const tradeTime = ts * 1000;\n  const diff = now - tradeTime;\n\n  const seconds = Math.floor(diff / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (days > 0) return `${days}d ago`;\n  if (hours > 0) return `${hours}h ago`;\n  if (minutes > 0) return `${minutes}m ago`;\n  return `${seconds}s ago`;\n}\n\nexport function formatCompactTime(ts?: number): string {\n  if (!ts && ts !== 0) return '-';\n  const d = new Date(ts * 1000);\n  const now = new Date();\n  const diffHours = (now.getTime() - d.getTime()) / (1000 * 60 * 60);\n\n  if (diffHours < 24) {\n    return formatTimeAgo(ts);\n  }\n\n  const month = d.toLocaleDateString('en-US', { month: 'short' });\n  const day = d.getDate();\n  const time = d.toLocaleTimeString('en-US', {\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  return `${month} ${day} ${time} UTC`;\n}\n\nexport function formatSmartAmount(value?: number): string {\n  if (value === undefined || value === null || !Number.isFinite(value)) return '-';\n  if (value === 0) return '0';\n\n  const abs = Math.abs(value);\n\n  // For very small numbers (< 0.0001), show with subscript zeros\n  if (abs < 0.0001 && abs > 0) {\n    const str = abs.toString();\n    if (str.includes('e-')) {\n      const [m, e] = str.split('e-');\n      const zeros = Number(e) - 1;\n      const digits = m.replace('.', '').slice(0, 4);\n      return `0.0{${zeros}}${digits}`;\n    }\n  }\n\n  // For numbers >= 1000, use compact notation\n  if (abs >= 1000) {\n    if (abs >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\n    if (abs >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\n    if (abs >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\n  }\n\n  // For numbers >= 1, use 2 decimal places\n  if (abs >= 1) return value.toFixed(2);\n\n  // For small numbers, use up to 4 significant digits\n  return value.toPrecision(4);\n}\n\nimport type { FetchMeta } from './types';\nexport type { FetchMeta } from './types';\n\nexport function formatFetchMeta(meta?: FetchMeta): string | undefined {\n  if (!meta) return undefined;\n  const parts: string[] = [];\n  let reason: string | undefined;\n  const tried = meta.tried?.split(',').filter(Boolean);\n  if (tried && tried.length > 0) {\n    const provs = tried.map((t) => {\n      const [p, r] = t.split(':');\n      if (r && !reason) reason = `${p}:${r}`;\n      return p;\n    });\n    let base = `Tried: ${provs.join('→')}`;\n    if (meta.effectiveTf) base += ` (tf: ${meta.effectiveTf})`;\n    parts.push(base);\n  } else if (meta.effectiveTf) {\n    parts.push(`TF: ${meta.effectiveTf}`);\n  }\n  if (meta.provider) parts.push(`Provider: ${meta.provider}`);\n  if (meta.items) parts.push(`Items: ${meta.items}`);\n  if (reason) parts.push(`reason: ${reason}`);\n  if (meta.remapped && meta.remapped !== '0') parts.push('remap: yes');\n  if (meta.invalidPool) parts.push(`invalid-pool: ${meta.invalidPool}`);\n  if (meta.cgAuth) parts.push(`cg-auth: ${meta.cgAuth}`);\n  if (meta.token) parts.push(`token: ${meta.token}`);\n  if (meta.priceSource) parts.push(`src: ${meta.priceSource}`);\n  return parts.join(' | ');\n}\n\n"
        }
    ]
}